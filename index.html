<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RSQ Elite | System Overseer</title>

<style>
:root {
    --primary: #4f7cff;
    --secondary: #00d2ff;
    --danger: #ff3b30;
    --success: #28cd41;
    --warning: #ffcc00;
    --glass: rgba(15, 20, 30, 0.95);
    --border: rgba(255, 255, 255, 0.08);
    --chat-bg: rgba(10, 12, 18, 0.95);
}

* {
    box-sizing: border-box;
}

body {
    margin: 0;
    background: #05070a;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    color: #f0f0f0;
    overflow: hidden;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Animations */
@keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
@keyframes slideIn { from { transform: translateX(-20px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
@keyframes spin { to { transform: rotate(360deg); } }

.animate-fade { animation: fadeIn 0.3s ease forwards; }
.animate-slide { animation: slideIn 0.3s ease forwards; }

#bg-wrap { 
    position: fixed; 
    inset: 0; 
    background: radial-gradient(ellipse at top, #0a0e1a 0%, #05070a 70%); 
    z-index: -2; 
}

/* Particle Background */
#particles {
    position: fixed;
    inset: 0;
    z-index: -1;
    pointer-events: none;
}

/* Stats Bar */
.stats-bar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background: rgba(10, 12, 18, 0.9);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid var(--border);
    padding: 8px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    z-index: 9999;
    height: 36px;
}

.stats-item {
    display: flex;
    align-items: center;
    gap: 6px;
    opacity: 0.8;
    transition: opacity 0.2s;
}

.stats-item:hover {
    opacity: 1;
}

.stats-icon {
    font-size: 11px;
}

.stats-value {
    font-weight: 600;
    color: var(--secondary);
    font-family: 'Monaco', 'Consolas', monospace;
}

.stats-label {
    font-size: 10px;
    opacity: 0.7;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* Panel Styling */
.panel {
    position: relative;
    z-index: 10;
    width: 420px;
    background: var(--glass);
    backdrop-filter: blur(30px);
    border: 1px solid var(--border);
    border-radius: 20px;
    padding: 30px;
    box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.hidden { display: none !important; }

/* Form Elements */
input, select, textarea {
    width: 100%;
    padding: 12px 16px;
    margin-top: 12px;
    background: rgba(0, 0, 0, 0.3);
    border: 1px solid var(--border);
    border-radius: 10px;
    color: white;
    font-size: 14px;
    font-family: inherit;
    transition: all 0.2s;
    outline: none;
}

input:focus, select:focus, textarea:focus {
    border-color: var(--primary);
    background: rgba(0, 0, 0, 0.4);
    box-shadow: 0 0 0 2px rgba(79, 124, 255, 0.1);
}

/* Buttons */
button {
    width: 100%;
    padding: 12px 20px;
    margin-top: 16px;
    border-radius: 10px;
    border: none;
    font-weight: 600;
    font-size: 14px;
    cursor: pointer;
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    color: white;
    transition: all 0.2s;
    position: relative;
    overflow: hidden;
}

button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
    transition: 0.5s;
}

button:hover::before {
    left: 100%;
}

button:hover {
    transform: translateY(-1px);
    box-shadow: 0 8px 20px rgba(79, 124, 255, 0.2);
}

button:active {
    transform: translateY(0);
}

button.danger { background: linear-gradient(135deg, #ff3b30, #ff6b52); }
button.warning { background: linear-gradient(135deg, #ffcc00, #ffaa00); color: #000; }
button.success { background: linear-gradient(135deg, #28cd41, #2ee058); }
button.mini { 
    padding: 4px 10px; 
    font-size: 11px; 
    margin-top: 0; 
    width: auto; 
    border-radius: 8px; 
}

/* Chat Toggle */
#chat-toggle {
    position: fixed; 
    bottom: 25px; 
    right: 25px; 
    width: 56px; 
    height: 56px;
    border-radius: 50%; 
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    display: flex;
    align-items: center; 
    justify-content: center; 
    cursor: pointer; 
    z-index: 1000;
    box-shadow: 
        0 6px 20px rgba(0,0,0,0.3),
        0 0 0 1px rgba(255, 255, 255, 0.1);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    border: none;
}

#chat-toggle:hover {
    transform: scale(1.1) rotate(5deg);
    box-shadow: 
        0 10px 30px rgba(79, 124, 255, 0.3),
        0 0 0 1px rgba(255, 255, 255, 0.2);
}

#chat-toggle svg { 
    width: 24px; 
    height: 24px; 
    fill: white; 
}

#unread-badge {
    position: absolute;
    top: -4px;
    right: -4px;
    background: var(--danger);
    color: white;
    font-size: 10px;
    font-weight: 700;
    min-width: 18px;
    height: 18px;
    border-radius: 9px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 4px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
}

/* Chat Window */
#chat-window {
    position: fixed;
    bottom: 100px;
    right: 25px;
    width: 380px;
    height: 520px;
    background: var(--chat-bg);
    backdrop-filter: blur(30px);
    border: 1px solid var(--border);
    border-radius: 16px;
    display: flex;
    flex-direction: column;
    z-index: 999;
    overflow: hidden;
    box-shadow: 
        0 25px 80px rgba(0, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

.chat-fullscreen {
    bottom: 0 !important; 
    right: 0 !important;
    width: 100vw !important; 
    height: 100vh !important;
    border-radius: 0 !important;
    z-index: 5000 !important;
}

/* Chat Header */
.chat-header {
    padding: 16px 20px;
    background: rgba(255, 255, 255, 0.03);
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
}

.chat-header-title {
    font-size: 14px;
    font-weight: 600;
    color: var(--secondary);
    letter-spacing: 0.5px;
}

.chat-header-stats {
    display: flex;
    align-items: center;
    gap: 12px;
    font-size: 11px;
    opacity: 0.7;
}

.chat-header-stats span {
    display: flex;
    align-items: center;
    gap: 4px;
}

/* Chat Messages Container */
#chat-msgs {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
    scroll-behavior: smooth;
    background: rgba(5, 7, 10, 0.4);
}

/* Pinned Message */
#pinned-area {
    background: linear-gradient(90deg, rgba(255, 204, 0, 0.1), rgba(255, 204, 0, 0.05));
    border-bottom: 1px solid rgba(255, 204, 0, 0.3);
    padding: 10px 16px;
    font-size: 12px;
    display: flex;
    align-items: center;
    gap: 10px;
    flex-shrink: 0;
}

#pinned-area .pin-icon {
    color: var(--warning);
    font-size: 12px;
    flex-shrink: 0;
}

#pinned-area .pin-text {
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Message Items */
.msg-item {
    margin-bottom: 12px;
    padding: 12px;
    border-radius: 12px;
    animation: fadeIn 0.2s ease forwards;
    position: relative;
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.05);
    transition: all 0.2s;
}

.msg-item:hover {
    background: rgba(255, 255, 255, 0.05);
    border-color: rgba(255, 255, 255, 0.1);
}

.msg-item.system {
    background: rgba(79, 124, 255, 0.08);
    border-color: rgba(79, 124, 255, 0.2);
    border-left: 3px solid var(--primary);
}

.msg-item.owner-msg {
    background: rgba(255, 204, 0, 0.05);
    border-color: rgba(255, 204, 0, 0.15);
    border-left: 3px solid var(--warning);
}

.msg-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 6px;
}

.msg-user {
    font-weight: 600;
    font-size: 12px;
    color: var(--secondary);
    display: flex;
    align-items: center;
    gap: 6px;
}

.msg-user .owner-badge {
    color: var(--warning);
    font-size: 10px;
}

.msg-time {
    font-size: 10px;
    opacity: 0.5;
    font-family: 'Monaco', 'Consolas', monospace;
}

.msg-content {
    font-size: 13px;
    line-height: 1.4;
    margin-bottom: 8px;
    word-break: break-word;
}

/* Reply Quote */
.reply-quote {
    font-size: 11px;
    opacity: 0.7;
    padding-left: 10px;
    border-left: 2px solid var(--primary);
    margin-bottom: 8px;
    font-style: italic;
    background: rgba(79, 124, 255, 0.05);
    padding: 6px 10px;
    border-radius: 6px;
}

/* Message Actions */
.msg-actions {
    position: absolute;
    top: 8px;
    right: 8px;
    display: none;
    gap: 4px;
    background: rgba(20, 25, 35, 0.9);
    backdrop-filter: blur(10px);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 4px;
    z-index: 10;
}

.msg-item:hover .msg-actions {
    display: flex;
}

.action-btn {
    width: 24px;
    height: 24px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 11px;
    transition: all 0.2s;
    background: transparent;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    padding: 0;
    margin: 0;
}

.action-btn:hover {
    background: rgba(255, 255, 255, 0.1);
    color: white;
    transform: scale(1.1);
}

.action-btn.delete:hover {
    background: rgba(255, 59, 48, 0.2);
    color: var(--danger);
}

/* Emoji Picker */
.emoji-picker {
    position: absolute;
    bottom: 45px;
    right: 8px;
    background: rgba(20, 25, 35, 0.95);
    backdrop-filter: blur(20px);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 8px;
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 4px;
    z-index: 100;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
    animation: fadeIn 0.2s ease;
}

.emoji-btn {
    width: 28px;
    height: 28px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
    background: transparent;
    border: none;
    padding: 0;
}

.emoji-btn:hover {
    background: rgba(79, 124, 255, 0.2);
    transform: scale(1.2);
}

/* Reactions */
.reactions-container {
    display: flex;
    flex-wrap: wrap;
    gap: 2px;
    margin-top: 6px;
    padding-top: 6px;
    border-top: 1px solid rgba(255, 255, 255, 0.05);
}

.reaction-btn-small {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    padding: 1px 6px;
    background: rgba(79, 124, 255, 0.1);
    border: 1px solid rgba(79, 124, 255, 0.15);
    border-radius: 8px;
    font-size: 10px;
    cursor: pointer;
    transition: all 0.2s;
    user-select: none;
    height: 20px;
    line-height: 1;
}

.reaction-btn-small:hover {
    background: rgba(79, 124, 255, 0.2);
    border-color: rgba(79, 124, 255, 0.3);
    transform: translateY(-1px);
}

.reaction-btn-small.active {
    background: rgba(79, 124, 255, 0.25);
    border-color: var(--primary);
    box-shadow: 0 0 0 1px rgba(79, 124, 255, 0.3);
}

.reaction-emoji-small {
    font-size: 10px;
}

.reaction-count-small {
    font-weight: 600;
    color: var(--secondary);
    font-size: 9px;
    min-width: 8px;
}

/* Chat Input Area */
.chat-input-area {
    padding: 16px;
    background: rgba(255, 255, 255, 0.02);
    border-top: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    gap: 10px;
    flex-shrink: 0;
}

.reply-preview {
    background: rgba(79, 124, 255, 0.1);
    border-radius: 8px;
    padding: 8px 12px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 11px;
    animation: slideIn 0.2s ease;
}

.reply-preview-text {
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    opacity: 0.9;
}

.cancel-reply {
    cursor: pointer;
    color: var(--danger);
    font-size: 12px;
    padding: 2px;
    border-radius: 4px;
    transition: all 0.2s;
}

.cancel-reply:hover {
    background: rgba(255, 59, 48, 0.1);
}

.chat-input-row {
    display: flex;
    gap: 10px;
    align-items: center;
}

#chat-input {
    flex: 1;
    margin: 0;
    padding: 12px 16px;
    font-size: 13px;
    background: rgba(0, 0, 0, 0.3);
    border: 1px solid var(--border);
    border-radius: 10px;
    min-height: 40px;
    resize: none;
    line-height: 1.4;
}

#chat-input:focus {
    background: rgba(0, 0, 0, 0.4);
    border-color: var(--primary);
}

#send-chat-btn {
    margin: 0;
    width: 80px;
    padding: 10px;
    font-size: 12px;
    font-weight: 600;
    background: linear-gradient(135deg, var(--primary), var(--secondary));
}

/* Scrollbar Styling */
#chat-msgs::-webkit-scrollbar {
    width: 6px;
}

#chat-msgs::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.02);
    border-radius: 3px;
}

#chat-msgs::-webkit-scrollbar-thumb {
    background: rgba(79, 124, 255, 0.2);
    border-radius: 3px;
}

#chat-msgs::-webkit-scrollbar-thumb:hover {
    background: rgba(79, 124, 255, 0.3);
}

/* Admin Panel */
.adminFull {
    position: fixed;
    inset: 15px;
    background: rgba(10, 12, 18, 0.98);
    backdrop-filter: blur(30px);
    border-radius: 20px;
    padding: 25px;
    z-index: 2000;
    overflow-y: auto;
    border: 1px solid var(--border);
    box-shadow: 0 30px 80px rgba(0, 0, 0, 0.5);
}

.log-box {
    background: rgba(255, 255, 255, 0.03);
    padding: 15px;
    border-radius: 12px;
    height: 350px;
    overflow-y: auto;
    border: 1px solid rgba(255, 255, 255, 0.05);
}

/* Toast Notifications */
.toast {
    position: fixed;
    top: 50px;
    right: 20px;
    background: rgba(20, 25, 35, 0.95);
    backdrop-filter: blur(20px);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px 18px;
    z-index: 10000;
    animation: slideIn 0.3s ease;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    max-width: 300px;
    border-left: 3px solid var(--primary);
}

.toast.success { border-left-color: var(--success); }
.toast.warning { border-left-color: var(--warning); }
.toast.error { border-left-color: var(--danger); }

/* Spinner */
.spinner {
    display: inline-block;
    width: 14px;
    height: 14px;
    border: 2px solid rgba(255, 255, 255, 0.1);
    border-radius: 50%;
    border-top-color: var(--primary);
    animation: spin 0.8s linear infinite;
}

/* Back Button */
.back-btn-container {
    position: absolute;
    top: 15px;
    right: 15px;
    z-index: 100;
}

/* Typing Indicator */
.typing-indicator {
    font-size: 11px;
    opacity: 0.7;
    padding: 0 16px 8px;
    font-style: italic;
    color: var(--secondary);
}

.typing-dots {
    display: inline-block;
}

.typing-dots span {
    animation: pulse 1.4s infinite;
    display: inline-block;
}

.typing-dots span:nth-child(2) { animation-delay: 0.2s; }
.typing-dots span:nth-child(3) { animation-delay: 0.4s; }

/* Empty State */
.empty-state {
    text-align: center;
    padding: 40px 20px;
    color: rgba(255, 255, 255, 0.5);
    font-size: 13px;
}

.empty-state-icon {
    font-size: 32px;
    margin-bottom: 10px;
    opacity: 0.3;
}

/* Connection Status */
.connection-status {
    position: fixed;
    bottom: 10px;
    left: 10px;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(10px);
    padding: 4px 10px;
    border-radius: 10px;
    font-size: 10px;
    display: flex;
    align-items: center;
    gap: 6px;
    z-index: 10000;
    opacity: 0.7;
    transition: opacity 0.3s;
}

.connection-status:hover {
    opacity: 1;
}

.connection-status.connected .status-dot {
    background: var(--success);
    box-shadow: 0 0 8px var(--success);
}

.connection-status.disconnected .status-dot {
    background: var(--danger);
    box-shadow: 0 0 8px var(--danger);
}

.status-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    animation: pulse 2s infinite;
}

/* NEW: GAME MANAGEMENT STYLES */
.game-management-section {
    background: linear-gradient(145deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    border-radius: 15px;
    padding: 20px;
    margin-bottom: 20px;
    border: 1px solid rgba(255,255,255,0.05);
    transition: all 0.3s ease;
}

.game-management-section:hover {
    border-color: rgba(255,255,255,0.1);
    transform: translateY(-2px);
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
}

.game-create-container {
    max-width: 500px;
    margin: 0 auto;
    padding: 25px;
    background: rgba(255,255,255,0.02);
    border-radius: 15px;
    border: 1px solid var(--border);
}

.image-preview-container {
    width: 120px;
    height: 120px;
    border-radius: 12px;
    border: 2px dashed var(--border);
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 15px auto;
    overflow: hidden;
    background: rgba(0,0,0,0.3);
    cursor: pointer;
    transition: all 0.3s ease;
}

.image-preview-container:hover {
    border-color: var(--primary);
    background: rgba(79, 124, 255, 0.05);
}

.image-preview {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: none;
}

.image-placeholder {
    text-align: center;
    color: rgba(255,255,255,0.5);
    font-size: 12px;
    padding: 10px;
}

.image-placeholder .icon {
    font-size: 24px;
    margin-bottom: 8px;
    display: block;
}

/* Games Dashboard */
.games-dashboard {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 15px;
    margin-top: 20px;
}

.game-card {
    background: rgba(255,255,255,0.03);
    border-radius: 12px;
    padding: 15px;
    border: 1px solid rgba(255,255,255,0.05);
    transition: all 0.3s ease;
    cursor: pointer;
    position: relative;
    overflow: hidden;
}

.game-card:hover {
    background: rgba(255,255,255,0.05);
    border-color: var(--primary);
    transform: translateY(-3px);
    box-shadow: 0 10px 20px rgba(79, 124, 255, 0.1);
}

.game-card-image {
    width: 100%;
    height: 100px;
    border-radius: 8px;
    object-fit: cover;
    margin-bottom: 10px;
    background: rgba(0,0,0,0.3);
}

.game-card-title {
    font-weight: 600;
    font-size: 14px;
    margin-bottom: 5px;
    color: white;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.game-card-id {
    font-size: 10px;
    opacity: 0.7;
    font-family: monospace;
    margin-bottom: 8px;
}

.game-card-scripts {
    font-size: 11px;
    opacity: 0.8;
    background: rgba(79, 124, 255, 0.1);
    padding: 3px 8px;
    border-radius: 10px;
    display: inline-block;
}

/* Script Management */
.script-management-container {
    max-width: 600px;
    margin: 0 auto;
    padding: 25px;
    background: rgba(255,255,255,0.02);
    border-radius: 15px;
    border: 1px solid var(--border);
}

.current-game-header {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid var(--border);
}

.current-game-image {
    width: 60px;
    height: 60px;
    border-radius: 10px;
    object-fit: cover;
}

.current-game-info h3 {
    margin: 0;
    font-size: 18px;
    color: white;
}

.current-game-info p {
    margin: 5px 0 0;
    font-size: 12px;
    opacity: 0.7;
    font-family: monospace;
}

.scripts-list {
    max-height: 400px;
    overflow-y: auto;
    margin: 20px 0;
    padding-right: 10px;
}

.script-item {
    background: rgba(255,255,255,0.03);
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 10px;
    border: 1px solid rgba(255,255,255,0.05);
    transition: all 0.2s ease;
}

.script-item:hover {
    background: rgba(255,255,255,0.05);
    border-color: rgba(255,255,255,0.1);
}

.script-url {
    font-family: monospace;
    font-size: 12px;
    color: var(--secondary);
    word-break: break-all;
    margin-bottom: 8px;
}

.script-actions {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
}

.add-script-form {
    background: rgba(79, 124, 255, 0.05);
    border-radius: 10px;
    padding: 20px;
    margin-top: 20px;
    border: 1px solid rgba(79, 124, 255, 0.1);
}

.add-script-form h4 {
    margin-top: 0;
    margin-bottom: 15px;
    color: var(--secondary);
}

.empty-state-games {
    text-align: center;
    padding: 60px 20px;
    color: rgba(255,255,255,0.5);
    font-size: 14px;
}

.empty-state-games .icon {
    font-size: 48px;
    margin-bottom: 15px;
    opacity: 0.3;
    display: block;
}

.empty-state-games p {
    font-size: 14px;
    margin-bottom: 20px;
}

/* File Input */
.file-input-wrapper {
    position: relative;
    margin: 15px 0;
}

.file-input-wrapper input[type="file"] {
    position: absolute;
    width: 100%;
    height: 100%;
    opacity: 0;
    cursor: pointer;
}

.file-input-label {
    display: block;
    padding: 12px 20px;
    background: rgba(79, 124, 255, 0.1);
    border: 2px dashed rgba(79, 124, 255, 0.3);
    border-radius: 10px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    color: var(--secondary);
    font-weight: 500;
}

.file-input-label:hover {
    background: rgba(79, 124, 255, 0.15);
    border-color: var(--primary);
}

.file-input-label .icon {
    margin-right: 8px;
}

/* Back Navigation */
.back-nav {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 20px;
    cursor: pointer;
    color: var(--secondary);
    font-weight: 500;
    transition: all 0.2s ease;
}

.back-nav:hover {
    color: white;
    transform: translateX(-3px);
}

.back-nav .icon {
    font-size: 18px;
}

/* Game Actions */
.game-actions {
    position: absolute;
    top: 10px;
    right: 10px;
    display: flex;
    gap: 5px;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.game-card:hover .game-actions {
    opacity: 1;
}

.game-action-btn {
    width: 28px;
    height: 28px;
    border-radius: 6px;
    background: rgba(0,0,0,0.6);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.1);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 12px;
    color: rgba(255,255,255,0.7);
    transition: all 0.2s ease;
}

.game-action-btn:hover {
    background: rgba(255,255,255,0.1);
    color: white;
    transform: scale(1.1);
}

.game-action-btn.delete:hover {
    background: rgba(255, 59, 48, 0.2);
    color: var(--danger);
}

/* Dashboard Header */
.dashboard-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.dashboard-header h3 {
    margin: 0;
}

.dashboard-stats {
    display: flex;
    gap: 15px;
    font-size: 12px;
    opacity: 0.8;
}

.dashboard-stats span {
    display: flex;
    align-items: center;
    gap: 5px;
}

/* Loading Overlay */
.loading-overlay {
    position: fixed;
    inset: 0;
    background: rgba(5, 7, 10, 0.9);
    backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    flex-direction: column;
    gap: 20px;
}

.loading-spinner-large {
    width: 40px;
    height: 40px;
    border: 3px solid rgba(255,255,255,0.1);
    border-radius: 50%;
    border-top-color: var(--primary);
    animation: spin 1s linear infinite;
}

.loading-text {
    color: var(--secondary);
    font-size: 14px;
    font-weight: 500;
}

/* Feedback UI */
.fb-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    background: rgba(255,255,255,0.05);
    border-radius: 8px;
    margin-bottom: 8px;
    border: 1px solid rgba(255,255,255,0.05);
    transition: all 0.2s ease;
}

.fb-item:hover {
    background: rgba(255,255,255,0.08);
    border-color: rgba(255,255,255,0.1);
}

/* Gradient Text */
.gradient-text {
    background: linear-gradient(90deg, var(--primary), var(--secondary));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

/* Key Management Styles */
.key-management-section {
    background: linear-gradient(145deg, rgba(255, 204, 0, 0.03), rgba(255, 204, 0, 0.01));
    border: 1px solid rgba(255, 204, 0, 0.1);
    border-radius: 12px;
    padding: 15px;
    margin-top: 15px;
    margin-bottom: 15px;
}

.key-item {
    background: rgba(255, 255, 255, 0.03);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 10px;
    border: 1px solid rgba(255, 255, 255, 0.05);
    transition: all 0.2s ease;
}

.key-item:hover {
    background: rgba(255, 255, 255, 0.05);
    border-color: rgba(255, 255, 255, 0.1);
}

.key-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}

.key-title {
    font-weight: 600;
    font-size: 13px;
    color: var(--warning);
    display: flex;
    align-items: center;
    gap: 6px;
}

.key-actions {
    display: flex;
    gap: 5px;
}

.key-url {
    font-family: monospace;
    font-size: 11px;
    color: var(--secondary);
    word-break: break-all;
    margin-bottom: 6px;
    opacity: 0.9;
}

.key-value {
    font-family: monospace;
    font-size: 11px;
    background: rgba(79, 124, 255, 0.1);
    padding: 4px 8px;
    border-radius: 6px;
    word-break: break-all;
    margin-bottom: 6px;
}

.no-keys-message {
    text-align: center;
    padding: 20px;
    color: rgba(255, 255, 255, 0.5);
    font-size: 12px;
}

.no-keys-message .icon {
    font-size: 24px;
    margin-bottom: 8px;
    opacity: 0.3;
    display: block;
}

.add-key-form {
    background: rgba(255, 204, 0, 0.05);
    border-radius: 10px;
    padding: 15px;
    border: 1px dashed rgba(255, 204, 0, 0.2);
    margin-top: 15px;
}

.add-key-form h5 {
    margin-top: 0;
    margin-bottom: 10px;
    color: var(--warning);
    font-size: 13px;
}

.form-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-bottom: 10px;
}

.key-visibility-toggle {
    cursor: pointer;
    font-size: 12px;
    color: var(--secondary);
    opacity: 0.8;
    transition: all 0.2s;
}

.key-visibility-toggle:hover {
    opacity: 1;
}

.copied-notification {
    position: absolute;
    background: rgba(40, 205, 65, 0.9);
    color: white;
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 4px;
    top: -20px;
    right: 0;
    animation: fadeIn 0.2s ease;
}

/* Script item modifications */
.script-item-with-keys {
    border-color: rgba(255, 204, 0, 0.2);
}

.script-keys-indicator {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    background: rgba(255, 204, 0, 0.1);
    color: var(--warning);
    font-size: 10px;
    padding: 2px 8px;
    border-radius: 10px;
    margin-left: 8px;
}

.keys-section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.keys-section-header h4 {
    margin: 0;
    font-size: 13px;
    color: var(--warning);
    display: flex;
    align-items: center;
    gap: 6px;
}

.toggle-keys-btn {
    background: transparent;
    border: 1px solid rgba(255, 204, 0, 0.2);
    color: var(--warning);
    padding: 4px 10px;
    border-radius: 6px;
    font-size: 10px;
    cursor: pointer;
    transition: all 0.2s;
}

.toggle-keys-btn:hover {
    background: rgba(255, 204, 0, 0.1);
    border-color: var(--warning);
}

.keys-container {
    max-height: 300px;
    overflow-y: auto;
    padding-right: 5px;
}

.keys-container::-webkit-scrollbar {
    width: 4px;
}

.keys-container::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.02);
}

.keys-container::-webkit-scrollbar-thumb {
    background: rgba(255, 204, 0, 0.2);
    border-radius: 2px;
}

/* Key Creation Modal */
.key-creation-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(5, 7, 10, 0.9);
    backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
}

.key-creation-content {
    background: var(--glass);
    border: 1px solid var(--border);
    border-radius: 20px;
    padding: 30px;
    width: 90%;
    max-width: 500px;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
}

.key-creation-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 25px;
}

.key-creation-header h3 {
    margin: 0;
    color: var(--warning);
    font-size: 20px;
}

.close-key-modal {
    background: rgba(255, 59, 48, 0.1);
    border: 1px solid var(--danger);
    color: var(--danger);
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
}

.close-key-modal:hover {
    background: rgba(255, 59, 48, 0.2);
    transform: scale(1.1);
}

.key-url-output {
    background: rgba(0, 0, 0, 0.3);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 15px;
    margin: 20px 0;
    word-break: break-all;
    font-family: monospace;
    font-size: 13px;
    color: var(--secondary);
}

.key-url-output-label {
    font-size: 12px;
    opacity: 0.7;
    margin-bottom: 5px;
    display: block;
}

.copy-key-url-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    margin-top: 10px;
}

.key-preview {
    background: rgba(79, 124, 255, 0.1);
    border: 1px solid rgba(79, 124, 255, 0.3);
    border-radius: 10px;
    padding: 15px;
    margin: 15px 0;
    font-family: monospace;
    font-size: 13px;
    word-break: break-all;
    color: var(--secondary);
}

.key-name-input-group {
    margin-bottom: 20px;
}

.key-name-input-group label {
    display: block;
    margin-bottom: 8px;
    font-size: 13px;
    opacity: 0.8;
}
</style>
</head>
<body>

<!-- Stats Bar -->
<div class="stats-bar">
    <div class="stats-item">
        <span class="stats-icon">üëÅÔ∏è</span>
        <span class="stats-label">Views:</span>
        <span class="stats-value" id="viewCount">0</span>
    </div>
    <div class="stats-item">
        <span class="stats-icon">‚ö°</span>
        <span class="stats-label">Live Active:</span>
        <span class="stats-value" id="activeCount">0</span>
    </div>
    <div class="stats-item">
        <span class="stats-icon">üïí</span>
        <span class="stats-label" id="currentTime">00:00</span>
    </div>
</div>

<!-- Particle Background -->
<canvas id="particles"></canvas>
<div id="bg-wrap"></div>

<!-- Connection Status -->
<div class="connection-status connected" id="connectionStatus">
    <div class="status-dot"></div>
    <span>Connected</span>
</div>

<!-- Loading Overlay -->
<div id="loadingOverlay" class="loading-overlay hidden">
    <div class="loading-spinner-large"></div>
    <div class="loading-text" id="loadingText">Loading...</div>
</div>

<!-- Auth Panel -->
<div id="authPanel" class="panel animate-fade">
    <div style="text-align:center; margin-bottom:30px;">
        <h1 style="margin:0; font-size:32px;" class="gradient-text">RSQ GATE</h1>
        <p style="font-size:12px; opacity:0.7; margin-top:8px;">Secure Access System</p>
    </div>
    
    <div id="loginView">
        <input id="l-user" placeholder="Username" autocomplete="username">
        <input id="l-pass" type="password" placeholder="Password" autocomplete="current-password">
        <button onclick="handleAuth('login')">
            <span>Sign In</span>
            <span class="spinner" style="display:none; margin-left:10px;" id="loginSpinner"></span>
        </button>
        <p style="text-align:center; font-size:12px; margin-top:20px; opacity:0.7;">
            New here? <a href="#" onclick="toggleAuth(true)" style="color:var(--secondary); text-decoration:none; font-weight:600;">Create Account</a>
        </p>
    </div>
    
    <div id="signupView" class="hidden">
        <input id="s-user" placeholder="Choose Username" autocomplete="username">
        <input id="s-pass" type="password" placeholder="Choose Password" autocomplete="new-password">
        <button onclick="handleAuth('signup')">
            <span>Sign Up</span>
            <span class="spinner" style="display:none; margin-left:10px;" id="signupSpinner"></span>
        </button>
        <p style="text-align:center; font-size:12px; margin-top:20px; opacity:0.7;">
            Have account? <a href="#" onclick="toggleAuth(false)" style="color:var(--secondary); text-decoration:none; font-weight:600;">Sign In</a>
        </p>
    </div>
    
    <div id="authStatus" style="text-align:center; color:var(--danger); font-size:12px; margin-top:15px; min-height:18px;"></div>
</div>

<!-- User Feedback UI -->
<div id="userFeedbackUI" class="panel animate-fade hidden">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
        <h2 style="margin:0;" class="gradient-text">üìù FEEDBACK</h2>
        <button class="mini danger" onclick="toggleFeedbackUI(false)" style="padding:6px 12px;">‚úï Exit</button>
    </div>
    
    <input id="fb-user" placeholder="Roblox Username" style="margin-bottom:10px;">
    <input id="fb-id" placeholder="Roblox UserID" style="margin-bottom:15px;">
    
    <div style="position:relative;">
        <textarea id="fb-msg" placeholder="Write your feedback here..." style="width:100%; height:120px; background:rgba(0,0,0,0.3); color:white; border:1px solid var(--border); border-radius:10px; padding:12px; resize:none; font-size:13px;"></textarea>
        <div style="position:absolute; right:12px; bottom:12px; font-size:10px; opacity:0.5;" id="fbCharCount">0/500</div>
    </div>
    
    <button onclick="submitFeedback()" style="margin-top:15px;">
        <span>Submit Feedback</span>
        <span class="spinner" style="display:none; margin-left:10px;" id="fbSpinner"></span>
    </button>
</div>

<!-- Main System -->
<div id="mainSystem" class="hidden">
    <div id="mainContentWrapper">
        <div id="userPanel" class="panel animate-fade">
            <div style="text-align:center; margin-bottom:25px;">
                <h1 style="margin:0; font-size:28px;" class="gradient-text">RSQ ELITE</h1>
                <p id="welcomeUser" style="font-size:11px; opacity:0.5; margin-top:5px;"></p>
            </div>
            
            <input id="userid" placeholder="Roblox UserID">
            <button id="genBtn" onclick="generateKey()">
                <span>Generate Access Key</span>
                <span class="spinner" style="display:none; margin-left:10px;" id="keySpinner"></span>
            </button>
            
            <div id="statusMsg" style="text-align:center; margin-top:15px; font-size:12px; color:var(--danger); min-height:18px;"></div>
            
            <div id="keyOut" style="text-align:center; margin-top:15px; color:var(--secondary); font-family:monospace; font-weight:bold; font-size:16px; padding:12px; background:rgba(0,0,0,0.3); border-radius:10px; border:1px solid rgba(79, 124, 255, 0.3); word-break: break-all;"></div>

            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:25px;">
                <button id="adminBtn" class="danger hidden">üëë Admin</button>
                <div style="display:flex; gap:10px;">
                    <button onclick="toggleFeedbackUI(true)" style="background:linear-gradient(135deg, #8a2be2, #4f7cff);">üí¨ Feedback</button>
                    <button onclick="logout()" style="background:rgba(255,255,255,0.05); border:1px solid var(--border);">üö™ Logout</button>
                </div>
            </div>
            
            <input id="adminInput" class="hidden" type="password" placeholder="Master Key" style="margin-top:15px;">
        </div>
    </div>

    <!-- Chat Toggle -->
    <div id="chat-toggle" onclick="toggleChat(true)">
        <svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/></svg>
        <div id="unread-badge" class="hidden">0</div>
    </div>

    <!-- Chat Window -->
    <div id="chat-window" class="hidden">
        <div class="back-btn-container">
            <button onclick="toggleChat(false)" class="mini danger" style="background:rgba(255,59,48,0.2); border:1px solid var(--danger);">‚Üê BACK</button>
        </div>
        
        <div class="chat-header">
            <div class="chat-header-title">NETWORK CHAT</div>
            <div class="chat-header-stats">
                <span><span class="stats-icon">üë§</span> <span id="chatOnlineCount">0</span></span>
                <span><span class="stats-icon">üí¨</span> <span id="chatMessageCount">0</span></span>
            </div>
        </div>
        
        <div id="pinned-area" class="hidden">
            <span class="pin-icon">üìå</span>
            <span class="pin-text" id="pinnedText"></span>
        </div>
        
        <div id="chat-msgs"></div>
        
        <!-- Typing Indicator -->
        <div id="typingIndicator" class="typing-indicator hidden">
            <span id="typingUsers"></span>
            <span class="typing-dots">
                <span>.</span><span>.</span><span>.</span>
            </span>
        </div>
        
        <!-- Input Area -->
        <div class="chat-input-area">
            <div id="reply-preview" class="reply-preview hidden">
                <span class="reply-preview-text" id="replyPreviewText"></span>
                <span class="cancel-reply" onclick="cancelReply()">‚úï</span>
            </div>
            
            <div class="chat-input-row">
                <textarea id="chat-input" placeholder="Type a message..." rows="1"></textarea>
                <button id="send-chat-btn" onclick="sendChat()">SEND</button>
            </div>
        </div>
    </div>
</div>

<!-- COMPLETE ADMIN PANEL WITH GAME MANAGEMENT -->
<div id="adminPanel" class="adminFull hidden">
    <!-- Default Admin View -->
    <div id="adminDefaultView">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:30px;">
            <div>
                <h2 style="margin:0;" class="gradient-text">üëë OVERSEER CONTROL</h2>
                <p style="font-size:11px; opacity:0.7; margin-top:5px;">Total Control Panel v2.1</p>
            </div>
            <div style="display:flex; gap:10px;">
                <button class="success" onclick="showGameCreateView()" style="width:auto; margin:0; padding:10px 20px;">
                    üéÆ Create Game
                </button>
                <button class="danger" onclick="toggleBanNowView(true)" style="width:auto; margin:0; padding:10px 20px;">
                    ‚ö° BAN NOW
                </button>
                <button class="warning" onclick="openAdminFeedbacks()" style="width:auto; margin:0; padding:10px 20px;">
                    üì© Feedbacks
                </button>
                <button onclick="closeAdmin()" style="width:auto; margin:0; background:#444; padding:10px 20px;">
                    üö™ Exit
                </button>
            </div>
        </div>

        <!-- Games Dashboard -->
        <div class="game-management-section">
            <div class="dashboard-header">
                <h3>üéÆ Game Management</h3>
                <div class="dashboard-stats">
                    <span><span class="stats-icon">üìÅ</span> <span id="totalGames">0 games</span></span>
                    <span><span class="stats-icon">üìú</span> <span id="totalScripts">0 scripts</span></span>
                </div>
            </div>
            
            <div id="gamesDashboard" class="games-dashboard">
                <!-- Games will be loaded here -->
            </div>
            
            <div id="noGamesMessage" class="empty-state-games hidden">
                <div class="icon">üéÆ</div>
                <p>No games created yet. Create your first game to get started!</p>
                <button class="success" onclick="showGameCreateView()" style="width:auto; margin:0; padding:10px 25px;">
                    üéÆ Create First Game
                </button>
            </div>
        </div>

        <!-- Broadcast & Chat Controls -->
        <div class="admin-section">
            <h3 style="margin-top:0; display:flex; align-items:center; gap:10px;">üî® Broadcast & Chat Controls</h3>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:15px;">
                <div>
                    <input id="globalMsgInput" placeholder="Broadcast Text" style="margin:0;">
                    <p style="font-size:10px; opacity:0.7; margin-top:5px;">Maximum 200 characters</p>
                </div>
                <div style="display:flex; gap:10px; align-items:flex-start;">
                    <button class="warning" onclick="sendGlobalMsg(true)" style="margin:0; flex:1;">üìå PIN LIVE</button>
                    <button class="warning" onclick="sendGlobalMsg(false)" style="margin:0; flex:1;">üì¢ ANNOUNCE</button>
                </div>
            </div>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:15px;">
                <button class="danger" onclick="clearGlobals()">üßπ PURGE GLOBALS</button>
                <button class="danger" onclick="clearAllChat()">üí• WIPE CHAT</button>
            </div>
        </div>

        <!-- Global Access Control -->
        <div class="admin-section" style="border-color:var(--danger); background:linear-gradient(145deg, rgba(255, 59, 48, 0.1), rgba(255, 59, 48, 0.05));">
            <h3 style="margin-top:0; color:var(--danger); display:flex; align-items:center; gap:10px;">‚ö†Ô∏è GLOBAL ACCESS CONTROL</h3>
            <p style="font-size: 11px; opacity: 0.8; margin-top: -5px; margin-bottom: 15px;">Warning: These actions affect all users system-wide.</p>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:15px;">
                <button class="danger" onclick="banAllKeyHolders()" style="margin:0; padding:12px;">‚õî BAN ALL KEY HOLDERS</button>
                <button class="success" onclick="unbanEveryone()" style="margin:0; padding:12px;">‚úÖ UNBAN ALL USERS</button>
            </div>
        </div>

        <!-- System Reset -->
        <div class="admin-section" style="border-color:var(--danger);">
            <h3 style="margin-top:0; color:var(--danger); display:flex; align-items:center; gap:10px;">‚ò¢Ô∏è SYSTEM RESET</h3>
            <div style="display:grid; grid-template-columns: 2fr 1fr; gap:15px; align-items:center;">
                <div>
                    <select id="resetTarget" style="margin:0; padding:12px;">
                        <option value="chat">üóëÔ∏è Clear Chat History Only</option>
                        <option value="bans">üö´ Clear All Blacklists (Bans)</option>
                        <option value="users">üë• Clear All User Accounts</option>
                        <option value="all">üí£ FACTORY RESET (Wipe Everything)</option>
                    </select>
                    <p style="font-size:10px; opacity:0.7; margin-top:5px;">Select reset target</p>
                </div>
                <button class="danger" onclick="masterReset()" style="margin:0; padding:12px;">üöÄ EXECUTE</button>
            </div>
        </div>

        <!-- Blacklist and Keys -->
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:20px; margin-top:20px;">
            <div>
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                    <h3 style="margin:0;">üö´ Active Blacklist</h3>
                    <span style="font-size:10px; opacity:0.7;" id="banCount">0 banned</span>
                </div>
                <div id="banLogs" class="log-box"></div>
            </div>
            <div>
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                    <h3 style="margin:0;">üîë System Keys</h3>
                    <div style="display:flex; gap:5px; align-items:center;">
                        <span style="font-size:10px; opacity:0.7;" id="keyCount">0 keys</span>
                        <button class="mini" onclick="renderAdminKeys()" style="padding:4px 8px;">üîÑ</button>
                    </div>
                </div>
                <div id="keyLogs" class="log-box"></div>
            </div>
        </div>
    </div>

    <!-- Game Creation View -->
    <div id="gameCreateView" class="hidden">
        <div class="back-nav" onclick="showGamesDashboard()">
            <span class="icon">‚Üê</span>
            <span>Back to Dashboard</span>
        </div>
        
        <div class="game-create-container">
            <h2 style="margin-top:0; text-align:center; margin-bottom:25px;">üéÆ Create New Game</h2>
            
            <!-- Image Preview -->
            <div class="image-preview-container" onclick="document.getElementById('gameImageInput').click()">
                <img id="gameImagePreview" class="image-preview" alt="Game Image">
                <div class="image-placeholder" id="imagePlaceholder">
                    <span class="icon">üìÅ</span>
                    Click to upload image
                    <br>
                    <small style="font-size:10px;">Max 2MB ‚Ä¢ JPG, PNG, GIF</small>
                </div>
            </div>
            
            <input type="file" id="gameImageInput" accept="image/*" class="hidden">
            
            <!-- Game Name -->
            <div style="margin: 20px 0;">
                <label style="font-size:12px; opacity:0.8; margin-bottom:5px; display:block;">Game Name</label>
                <input type="text" id="gameNameInput" placeholder="Enter game name" maxlength="50">
            </div>
            
            <!-- Game ID -->
            <div style="margin: 20px 0;">
                <label style="font-size:12px; opacity:0.8; margin-bottom:5px; display:block;">Roblox Game ID</label>
                <input type="text" id="gameIdInput" placeholder="Enter Roblox Place ID" pattern="\d+" maxlength="10">
                <p style="font-size:10px; opacity:0.7; margin-top:5px;">Enter the numeric Place ID from Roblox</p>
            </div>
            
            <!-- Create Button -->
            <button class="success" onclick="createGame()" style="margin-top:25px;">
                <span>üéÆ Create Game</span>
            </button>
            
            <div id="gameCreateStatus" style="text-align:center; margin-top:15px; font-size:12px; color:var(--danger); min-height:18px;"></div>
        </div>
    </div>

    <!-- Script Management View -->
    <div id="scriptManagementView" class="hidden">
        <div class="back-nav" onclick="showGamesDashboard()">
            <span class="icon">‚Üê</span>
            <span>Back to Dashboard</span>
        </div>
        
        <div class="script-management-container">
            <div class="current-game-header">
                <img id="currentGameImage" class="current-game-image" alt="Game Image">
                <div class="current-game-info">
                    <h3 id="currentGameName"></h3>
                    <p id="currentGameId"></p>
                </div>
            </div>
            
            <h3 style="margin-top:0;">üìú Script Management</h3>
            
            <div id="scriptsList" class="scripts-list">
                <!-- Scripts will be loaded here -->
            </div>
            
            <div id="noScriptsMessage" class="empty-state-games hidden">
                <div class="icon">üìú</div>
                <p>No scripts added yet. Add your first script below.</p>
            </div>
            
            <!-- Add Script Form -->
            <div class="add-script-form">
                <h4>‚ûï Add New Script</h4>
                
                <!-- Script Name Input -->
                <div style="margin-bottom:12px;">
                    <input type="text" id="scriptNameInput" placeholder="Script Name" style="margin-bottom:8px;">
                    <p style="font-size:10px; opacity:0.7; margin-top:2px;">Give your script a descriptive name</p>
                </div>
                
                <!-- Script URL Input -->
                <div style="margin-bottom:12px;">
                    <input type="text" id="scriptUrlInput" placeholder="Paste script URL here..." style="margin-bottom:8px;">
                    <p style="font-size:10px; opacity:0.7; margin-top:2px;">
                        Direct URL to your script (http:// or https://)
                    </p>
                </div>
                
                <button onclick="addScriptToGame()" style="width:auto; margin:0;">
                    <span>‚ûï Add Script</span>
                </button>
                <div id="scriptAddStatus" style="text-align:center; margin-top:10px; font-size:12px; color:var(--danger); min-height:18px;"></div>
            </div>
        </div>
    </div>

    <!-- Ban Now View -->
    <div id="banNowView" class="hidden">
        <div class="ban-focus-container">
            <div style="text-align:center; margin-bottom:25px;">
                <h2 style="color:var(--danger); margin:0; font-size:24px;" class="gradient-text">üî® RESTRICT USER</h2>
                <p style="font-size:11px; opacity:0.7; margin-top:5px;">Immediate action required</p>
            </div>
            
            <input id="focusBanId" placeholder="Roblox UserID" style="margin-bottom:15px;">
            <input id="focusBanUser" placeholder="Username to Ban" style="margin-bottom:15px;">
            
            <div style="position:relative;">
                <textarea id="focusBanReason" placeholder="Reason for restriction..." style="height:100px; resize:none; margin-bottom:20px;"></textarea>
                <div style="position:absolute; right:12px; bottom:30px; font-size:10px; opacity:0.5;" id="reasonCharCount">0/200</div>
            </div>
            
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:15px;">
                <button class="danger" onclick="executeFocusBan()" style="padding:12px;">‚ö° BAN USER</button>
                <button onclick="toggleBanNowView(false)" style="background:#444; padding:12px;">‚Ü©Ô∏è CANCEL</button>
            </div>
        </div>
    </div>

    <!-- Admin Feedback List View -->
    <div id="adminFeedbackListView" class="hidden">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
            <div>
                <h2 style="margin:0;" class="gradient-text">üì© USER FEEDBACKS</h2>
                <p style="font-size:11px; opacity:0.7; margin-top:5px;">Read and manage user submissions</p>
            </div>
            <button onclick="returnToAdminPanel()" style="width:auto; margin:0; background:#444; padding:10px 20px;">‚Ü©Ô∏è Return</button>
        </div>
        
        <div style="position:relative;">
            <input id="fbSearch" placeholder="Search UserID or Username..." oninput="renderAdminFeedbacks()" style="padding:12px; font-size:13px;">
            <div style="position:absolute; right:12px; top:50%; transform:translateY(-50%); opacity:0.5;">üîç</div>
        </div>
        
        <div id="fbLogs" class="log-box" style="margin-top:15px; height: 500px;"></div>
    </div>

    <!-- Admin View Feedback UI -->
    <div id="adminViewFeedbackUI" class="hidden">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
            <h2 id="viewFbTitle" style="margin:0;" class="gradient-text">üìÑ FEEDBACK VIEW</h2>
            <button onclick="closeSingleFeedback()" style="width:auto; margin:0; background:var(--danger); padding:10px 20px;">‚úï Close</button>
        </div>
        <div id="viewFbContent" style="background:linear-gradient(145deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02)); padding:25px; border-radius:15px; margin-top:20px; line-height: 1.6; min-height: 200px; border:1px solid rgba(255,255,255,0.1);"></div>
    </div>
</div>

<!-- Key Creation Modal -->
<div id="keyCreationModal" class="key-creation-modal hidden">
    <div class="key-creation-content">
        <div class="key-creation-header">
            <h3>üîë Create Script Key</h3>
            <button class="close-key-modal" onclick="closeKeyCreationModal()">‚úï</button>
        </div>
        
        <div class="key-name-input-group">
            <label for="newKeyName">Key Name</label>
            <input type="text" id="newKeyName" placeholder="Enter a name for this key (e.g., Premium Key, VIP Key)">
        </div>
        
        <div class="key-name-input-group">
            <label for="newKeyValue">Key Value</label>
            <input type="text" id="newKeyValue" placeholder="Enter the actual key value (will be hidden)">
            <p style="font-size:10px; opacity:0.7; margin-top:5px;">This is the actual key that users will enter</p>
        </div>
        
        <div class="key-name-input-group">
            <label for="newKeyURL">Key URL (Optional)</label>
            <input type="text" id="newKeyURL" placeholder="Optional: URL associated with this key">
        </div>
        
        <div class="key-preview" id="keyPreview">
            <strong>Key Preview:</strong><br>
            <span id="keyPreviewText">Fill in the fields above to see preview</span>
        </div>
        
        <div class="key-url-output">
            <span class="key-url-output-label">URL to Copy:</span>
            <span id="keyURLOutput">Will be generated after creating key</span>
        </div>
        
        <button class="success copy-key-url-btn" onclick="createNewKey()" id="createKeyBtn">
            <span>üîë Create Key</span>
        </button>
        
        <button class="warning" onclick="generateRandomKeyValue()" style="margin-top:10px;">
            <span>üé≤ Generate Random Key</span>
        </button>
        
        <div id="keyCreationStatus" style="text-align:center; margin-top:15px; font-size:12px; color:var(--danger); min-height:18px;"></div>
    </div>
</div>

<!-- Updated JavaScript section (replace the entire script from line 3310 onward) -->
<script>
// ==================================================
// JSONBIN API CONFIGURATION
// ==================================================
const JSONBIN_BIN_ID = "6952cbcdd0ea881f4047f5ff";
const JSONBIN_API_KEY = "$2a$10$f6r4B1gP.MfB1k49kq2m7eEzyesjD9KWP5zCa6QtJKW5ZBhL1M0/O";
const JSONBIN_API_URL = "https://api.jsonbin.io/v3/b";
const JSONBIN_MASTER_KEY = JSONBIN_API_KEY; // Since it's a master key

// Data cache
let dataCache = null;
let lastFetchTime = 0;
const CACHE_TTL = 30000; // 30 seconds cache
let apiFailureCount = 0;
const MAX_API_FAILURES = 3;

// Current system state
let currentUser = null;
let currentKey = null;
let isAdminAuthenticated = false;

// Chat state
let chatUsers = new Set();
let activeReplyTarget = null;
let activeEmojiPicker = null;
let typingTimeout = null;
let lastTypingTime = 0;
let lastSeenMessageTime = 0;
let unreadCount = 0;

// Game management state
let currentGameId = null;
let currentScriptIndexForKey = null;
let currentScriptForKey = null;
let selectedGame = null;

// ==================================================
// JSONBIN API HELPER FUNCTIONS
// ==================================================
async function makeJsonBinRequest(method = 'GET', data = null, version = 'latest') {
    const url = `${JSONBIN_API_URL}/${JSONBIN_BIN_ID}/${version}`;
    
    try {
        const headers = {
            'X-Master-Key': JSONBIN_MASTER_KEY,
            'Content-Type': 'application/json',
            'X-Bin-Versioning': 'false'
        };
        
        const options = {
            method: method,
            headers: headers
        };
        
        if (data && (method === 'PUT' || method === 'POST')) {
            options.body = JSON.stringify(data);
        }
        
        const response = await fetch(url, options);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        return await response.json();
    } catch (error) {
        console.error('JSONBin API error:', error);
        throw error;
    }
}

async function createInitialBin() {
    const initialData = {
        keys: {},
        games: [],
        bans: {},
        feedbacks: [],
        chats: [],
        pinned: null,
        admins: {},
        settings: {
            version: "2.0",
            created: Date.now(),
            last_updated: Date.now()
        }
    };
    
    try {
        const result = await makeJsonBinRequest('PUT', initialData);
        showToast('‚úÖ New database created with JSONBin', 'success');
        return true;
    } catch (error) {
        console.error('Failed to create initial bin:', error);
        showToast('‚ùå Failed to initialize database', 'error');
        return false;
    }
}

// ==================================================
// DATABASE INITIALIZATION
// ==================================================
async function initializeDatabase() {
    showLoading('Initializing database...');
    
    try {
        // Try to fetch existing data
        const response = await makeJsonBinRequest('GET');
        
        if (response.record) {
            dataCache = response.record;
        } else {
            // Create initial database if it doesn't exist
            if (!await createInitialBin()) {
                throw new Error('Failed to create initial database');
            }
            const newResponse = await makeJsonBinRequest('GET');
            dataCache = newResponse.record;
        }
        
        // Start background sync
        setInterval(() => {
            fetchData(false).catch(console.error);
        }, 60000); // Sync every minute
        
        hideLoading();
        return true;
    } catch (error) {
        console.error('Database initialization failed:', error);
        // Try to create new database
        if (!await createInitialBin()) {
            hideLoading();
            return false;
        }
        
        hideLoading();
        return true;
    }
}

// ==================================================
// API FUNCTIONS
// ==================================================
async function api(endpoint, method = 'GET', data = null) {
    showLoading();
    
    try {
        if (method === 'GET') {
            const response = await makeJsonBinRequest('GET');
            const fullData = response.record;
            
            // If specific endpoint requested, return that part
            if (endpoint === 'games') {
                return { record: { games: fullData.games || [] } };
            } else if (endpoint === 'keys') {
                return { record: { keys: fullData.keys || {} } };
            } else if (endpoint === 'bans') {
                return { record: { bans: fullData.bans || {} } };
            } else if (endpoint === 'feedbacks') {
                return { record: { feedbacks: fullData.feedbacks || [] } };
            } else if (endpoint === 'chat') {
                return { record: { chat: fullData.chats || [] } };
            }
            
            return { record: fullData };
        }
        
        if (method === 'PUT') {
            // Get current data first
            const currentResponse = await makeJsonBinRequest('GET');
            let currentData = currentResponse.record;
            
            // Merge new data
            if (data) {
                Object.assign(currentData, data);
                currentData.settings = currentData.settings || {};
                currentData.settings.last_updated = Date.now();
            }
            
            const updateResponse = await makeJsonBinRequest('PUT', currentData);
            
            // Update cache
            dataCache = updateResponse.record;
            lastFetchTime = Date.now();
            
            // Update connection status
            updateConnectionStatus(true);
            
            return { record: updateResponse.record };
        }
        
        throw new Error(`Unsupported method: ${method}`);
        
    } catch (error) {
        console.error('API Error:', error);
        apiFailureCount++;
        
        if (apiFailureCount >= MAX_API_FAILURES) {
            showToast('‚ö†Ô∏è Connection issues. Using cached data.', 'warning');
        }
        
        updateConnectionStatus(false);
        throw error;
    } finally {
        hideLoading();
    }
}

async function batchUpdate(updates) {
    showLoading();
    
    try {
        // Get current data
        const currentResponse = await makeJsonBinRequest('GET');
        let currentData = currentResponse.record;
        
        // Apply all updates
        for (const update of updates) {
            Object.assign(currentData, update);
        }
        
        currentData.settings = currentData.settings || {};
        currentData.settings.last_updated = Date.now();
        
        const updateResponse = await makeJsonBinRequest('PUT', currentData);
        
        // Update cache
        dataCache = updateResponse.record;
        lastFetchTime = Date.now();
        apiFailureCount = 0;
        
        updateConnectionStatus(true);
        return { success: true, record: updateResponse.record };
    } catch (error) {
        console.error('Batch update failed:', error);
        updateConnectionStatus(false);
        throw error;
    } finally {
        hideLoading();
    }
}

async function fetchData(forceRefresh = false) {
    const now = Date.now();
    
    if (!forceRefresh && dataCache && (now - lastFetchTime) < CACHE_TTL) {
        return dataCache;
    }
    
    try {
        const response = await api('data', 'GET');
        dataCache = response.record;
        lastFetchTime = now;
        apiFailureCount = 0;
        
        updateConnectionStatus(true);
        return dataCache;
    } catch (error) {
        console.error('Failed to fetch data:', error);
        
        // Return cached data if available
        if (dataCache) {
            return dataCache;
        }
        
        throw error;
    }
}

function updateConnectionStatus(connected) {
    const statusElement = document.getElementById('connectionStatus');
    if (!statusElement) return;
    
    if (connected) {
        statusElement.className = 'connection-status connected';
        statusElement.innerHTML = '<div class="status-dot"></div><span>Connected</span>';
    } else {
        statusElement.className = 'connection-status disconnected';
        statusElement.innerHTML = '<div class="status-dot"></div><span>Disconnected</span>';
    }
}

// ==================================================
// UTILITY FUNCTIONS (Keep these the same)
// ==================================================
function showLoading(text = 'Loading...') {
    const overlay = document.getElementById('loadingOverlay');
    const loadingText = document.getElementById('loadingText');
    if (overlay && loadingText) {
        loadingText.textContent = text;
        overlay.classList.remove('hidden');
    }
}

function hideLoading() {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) {
        overlay.classList.add('hidden');
    }
}

function showToast(message, type = 'info', duration = 3000) {
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;
    
    document.body.appendChild(toast);
    
    // Auto remove after duration
    setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateX(100%)';
        setTimeout(() => toast.remove(), 300);
    }, duration);
}

function moderate(text) {
    if (!text) return false;
    
    const bannedWords = ['badword1', 'badword2']; // Add your banned words
    const lowerText = text.toLowerCase();
    
    for (const word of bannedWords) {
        if (lowerText.includes(word)) {
            return true;
        }
    }
    
    return false;
}

function getUserIdentifier() {
    let userId = localStorage.getItem('RSQ_USER_ID');
    if (!userId) {
        userId = 'user_' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        localStorage.setItem('RSQ_USER_ID', userId);
    }
    return userId;
}

// ==================================================
// STATS AND TRACKING FUNCTIONS
// ==================================================
function updateStatsDisplay() {
    const viewCountElem = document.getElementById('viewCount');
    const activeCountElem = document.getElementById('activeCount');
    const chatOnlineCountElem = document.getElementById('chatOnlineCount');
    const chatMessageCountElem = document.getElementById('chatMessageCount');
    
    if (viewCountElem) viewCountElem.textContent = '0';
    if (activeCountElem) activeCountElem.textContent = '0';
    if (chatOnlineCountElem) chatOnlineCountElem.textContent = chatUsers.size;
    
    // Update chat message count
    if (dataCache && dataCache.chats) {
        if (chatMessageCountElem) chatMessageCountElem.textContent = dataCache.chats.length;
    }
    
    // Update current time
    const timeElem = document.getElementById('currentTime');
    if (timeElem) {
        const now = new Date();
        timeElem.textContent = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }
}

function trackViewAndActivity() {
    const userId = getUserIdentifier();
    const now = Date.now();
    
    // Track view
    if (!localStorage.getItem('hasTrackedView')) {
        localStorage.setItem('hasTrackedView', 'true');
        // You could send this to your API if needed
    }
    
    // Update activity
    localStorage.setItem('lastActivity', now.toString());
    
    updateStatsDisplay();
}

// ==================================================
// CHAT FUNCTIONS (Keep all chat functions the same)
// ==================================================
function updateChat() {
    if (!dataCache || !dataCache.chats) return;
    
    const currentUser = getUserIdentifier();
    const bans = dataCache.bans || {};
    
    // Check if user is banned
    if (bans[currentUser]) {
        document.getElementById('chat-toggle').classList.add('hidden');
        document.getElementById('chat-window').classList.add('hidden');
        return;
    }
    
    const chatToggle = document.getElementById('chat-toggle');
    const chatWindow = document.getElementById('chat-window');
    
    if (chatToggle) chatToggle.classList.remove('hidden');
    
    // Check for pinned message
    if (dataCache.pinned) {
        const pinnedArea = document.getElementById('pinned-area');
        const pinnedText = document.getElementById('pinnedText');
        if (pinnedArea && pinnedText) {
            pinnedArea.classList.remove('hidden');
            pinnedText.textContent = dataCache.pinned.text || dataCache.pinned;
        }
    }
    
    renderMessages();
}

function renderMessages() {
    if (!dataCache || !dataCache.chats) return;
    
    const container = document.getElementById('chat-msgs');
    if (!container) return;
    
    const currentUser = getUserIdentifier();
    const messages = dataCache.chats;
    
    if (messages.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üí¨</div>
                <div>No messages yet. Be the first to say hello!</div>
            </div>
        `;
        return;
    }
    
    const html = messages.map((msg, index) => {
        const isSystem = msg.user === 'SYSTEM';
        const isOwner = msg.user === 'SUPER_ADMIN';
        const isCurrentUser = msg.user === currentUser;
        
        const time = new Date(msg.timestamp || Date.now()).toLocaleTimeString([], { 
            hour: '2-digit', 
            minute: '2-digit' 
        });
        
        let replySection = '';
        if (msg.replyTo) {
            replySection = `
                <div class="reply-quote">
                    Replying to <strong>${msg.replyTo.user || 'Unknown'}</strong>: ${msg.replyTo.text || ''}
                </div>
            `;
        }
        
        let reactionsSection = '';
        if (msg.reactions && Object.keys(msg.reactions).length > 0) {
            const reactionHtml = Object.entries(msg.reactions).map(([emoji, users]) => {
                const isReacted = users.includes(currentUser);
                return `
                    <button class="reaction-btn-small ${isReacted ? 'active' : ''}" 
                            onclick="handleReaction(${index}, '${emoji}')"
                            title="${users.join(', ')}">
                        <span class="reaction-emoji-small">${emoji}</span>
                        <span class="reaction-count-small">${users.length}</span>
                    </button>
                `;
            }).join('');
            
            reactionsSection = `
                <div class="reactions-container">
                    ${reactionHtml}
                </div>
            `;
        }
        
        const deleteBtn = isAdminAuthenticated ? 
            `<button class="action-btn delete" onclick="deleteMessage(${index})" title="Delete">üóëÔ∏è</button>` : '';
        
        return `
            <div class="msg-item ${isSystem ? 'system' : ''} ${isOwner ? 'owner-msg' : ''} ${isCurrentUser ? 'current-user' : ''}" 
                 data-index="${index}"
                 onmouseenter="showMessageActions(${index})"
                 onmouseleave="hideMessageActions(${index})">
                
                <div class="msg-header">
                    <div class="msg-user">
                        ${isOwner ? '<span class="owner-badge">üëë</span>' : ''}
                        ${msg.user}
                    </div>
                    <div class="msg-time">${time}</div>
                </div>
                
                ${replySection}
                
                <div class="msg-content">
                    ${msg.txt}
                </div>
                
                ${reactionsSection}
                
                <div class="msg-actions" id="msg-actions-${index}">
                    <button class="action-btn" onclick="openEmojiPicker(${index})" title="Add reaction">üòä</button>
                    <button class="action-btn" onclick="setupReply(${index}, '${msg.user}', '${msg.txt.replace(/'/g, "\\'")}')" title="Reply">‚Ü©Ô∏è</button>
                    ${deleteBtn}
                </div>
            </div>
        `;
    }).join('');
    
    container.innerHTML = html;
    
    // Scroll to bottom
    if (container.scrollHeight > container.clientHeight) {
        container.scrollTop = container.scrollHeight;
    }
    
    // Update unread badge
    if (messages.length > 0 && messages[messages.length - 1].timestamp > lastSeenMessageTime) {
        lastSeenMessageTime = Date.now();
        unreadCount++;
        updateUnreadBadge();
    }
}

function updateUnreadBadge() {
    const badge = document.getElementById('unread-badge');
    if (!badge) return;
    
    if (unreadCount > 0) {
        badge.textContent = unreadCount > 99 ? '99+' : unreadCount.toString();
        badge.classList.remove('hidden');
    } else {
        badge.classList.add('hidden');
    }
}

// ==================================================
// MESSAGE ACTIONS (Keep all message functions the same)
// ==================================================
function showMessageActions(index) {
    const actions = document.getElementById(`msg-actions-${index}`);
    if (actions) {
        actions.style.display = 'flex';
    }
}

function hideMessageActions(index) {
    const actions = document.getElementById(`msg-actions-${index}`);
    if (actions) {
        actions.style.display = 'none';
    }
}

function openEmojiPicker(index) {
    if (activeEmojiPicker) {
        hideEmojiPicker();
    }
    
    activeEmojiPicker = index;
    
    const emojis = ['‚ù§Ô∏è', 'üòÇ', 'üî•', 'üíÄ', 'üòÆ', 'üò¢', 'üëç', 'üëé', 'üéâ', 'üëè', 'ü§î', 'üòç'];
    const emojiHtml = emojis.map(emoji => `
        <button class="emoji-btn" onclick="handleReaction(${index}, '${emoji}')">${emoji}</button>
    `).join('');
    
    const picker = document.createElement('div');
    picker.className = 'emoji-picker';
    picker.id = `emoji-picker-${index}`;
    picker.innerHTML = emojiHtml;
    
    const msgElement = document.querySelector(`[data-index="${index}"]`);
    if (msgElement) {
        msgElement.appendChild(picker);
    }
    
    updateChat();
}

function hideEmojiPicker() {
    if (activeEmojiPicker !== null) {
        const picker = document.getElementById(`emoji-picker-${activeEmojiPicker}`);
        if (picker) picker.remove();
        activeEmojiPicker = null;
        updateChat();
    }
}

async function handleReaction(index, emoji) {
    hideEmojiPicker();
    
    const currentUser = getUserIdentifier();
    const data = await fetchData();
    
    if (!data.chats || !data.chats[index]) {
        showToast('Message not found', 'error');
        return;
    }
    
    const message = data.chats[index];
    if (!message.reactions) {
        message.reactions = {};
    }
    
    if (!message.reactions[emoji]) {
        message.reactions[emoji] = [];
    }
    
    const userIndex = message.reactions[emoji].indexOf(currentUser);
    if (userIndex > -1) {
        // Remove reaction
        message.reactions[emoji].splice(userIndex, 1);
        if (message.reactions[emoji].length === 0) {
            delete message.reactions[emoji];
        }
        showToast('Reaction removed', 'info');
    } else {
        // Add reaction
        message.reactions[emoji].push(currentUser);
        showToast(`Reacted with ${emoji}`, 'success');
    }
    
    await batchUpdate([{ chats: data.chats }]);
    renderMessages();
}

function setupReply(index, user, text) {
    activeReplyTarget = index;
    
    const preview = document.getElementById('replyPreviewText');
    const container = document.getElementById('reply-preview');
    
    if (preview && container) {
        preview.textContent = `Replying to ${user}: ${text.substring(0, 50)}${text.length > 50 ? '...' : ''}`;
        container.classList.remove('hidden');
    }
    
    const input = document.getElementById('chat-input');
    if (input) input.focus();
}

function cancelReply() {
    activeReplyTarget = null;
    const container = document.getElementById('reply-preview');
    if (container) container.classList.add('hidden');
}

async function sendChat() {
    const input = document.getElementById('chat-input');
    if (!input) return;
    
    const text = input.value.trim();
    if (!text) return;
    
    // Check for banned content
    if (moderate(text)) {
        showToast('Message contains blocked content', 'error');
        return;
    }
    
    // Check if user is banned
    const data = await fetchData();
    const currentUser = getUserIdentifier();
    const bans = data.bans || {};
    
    if (bans[currentUser]) {
        showToast('You are banned from chat', 'error', 3000);
        return;
    }
    
    const message = {
        user: currentUser,
        txt: text,
        timestamp: Date.now()
    };
    
    if (activeReplyTarget !== null && data.chats[activeReplyTarget]) {
        const repliedMsg = data.chats[activeReplyTarget];
        message.replyTo = {
            user: repliedMsg.user,
            text: repliedMsg.txt.substring(0, 100)
        };
    }
    
    if (!data.chats) {
        data.chats = [];
    }
    
    data.chats.push(message);
    
    // Keep only last 100 messages
    if (data.chats.length > 100) {
        data.chats = data.chats.slice(-100);
    }
    
    await batchUpdate([{ chats: data.chats }]);
    
    input.value = '';
    cancelReply();
    
    // Clear typing indicator
    if (typingTimeout) clearTimeout(typingTimeout);
    const typingIndicator = document.getElementById('typingIndicator');
    if (typingIndicator) typingIndicator.classList.add('hidden');
}

async function deleteMessage(index) {
    if (!isAdminAuthenticated) {
        showToast('Admin access required', 'error');
        return;
    }
    
    if (!confirm('Delete this message?')) return;
    
    const data = await fetchData();
    if (!data.chats || !data.chats[index]) {
        showToast('Message not found', 'error');
        return;
    }
    
    data.chats.splice(index, 1);
    await batchUpdate([{ chats: data.chats }]);
    
    showToast('Message deleted', 'warning');
    renderMessages();
}

function handleTyping() {
    const now = Date.now();
    lastTypingTime = now;
    
    if (typingTimeout) clearTimeout(typingTimeout);
    
    typingTimeout = setTimeout(() => {
        const typingIndicator = document.getElementById('typingIndicator');
        if (typingIndicator) typingIndicator.classList.add('hidden');
    }, 1000);
}

// ==================================================
// KEY MANAGEMENT FUNCTIONS (Keep all key functions the same)
// ==================================================
async function generateKey() {
    const userIdInput = document.getElementById('userid');
    const statusMsg = document.getElementById('statusMsg');
    const keyOut = document.getElementById('keyOut');
    const spinner = document.getElementById('keySpinner');
    
    if (!userIdInput || !statusMsg || !keyOut) return;
    
    const userId = userIdInput.value.trim();
    if (!userId) {
        statusMsg.textContent = 'Please enter a Roblox UserID';
        return;
    }
    
    if (!/^\d+$/.test(userId)) {
        statusMsg.textContent = 'Invalid UserID. Must be numeric.';
        return;
    }
    
    if (spinner) spinner.style.display = 'inline-block';
    statusMsg.textContent = 'Generating key...';
    
    try {
        const data = await fetchData();
        if (!data.keys) {
            data.keys = {};
        }
        
        // Generate random key
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
        let key = '';
        for (let i = 0; i < 16; i++) {
            key += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        
        // Save key to database
        data.keys[key] = {
            rbx: userId,
            exp: "INF",
            created: Date.now(),
            added_by: getUserIdentifier()
        };
        
        await batchUpdate([{ keys: data.keys }]);
        
        keyOut.textContent = key;
        statusMsg.textContent = '‚úÖ Key generated successfully!';
        userIdInput.value = '';
        
        showToast('Key generated and saved to database', 'success');
    } catch (error) {
        console.error('Error generating key:', error);
        statusMsg.textContent = '‚ùå Failed to generate key';
        showToast('Failed to generate key', 'error');
    } finally {
        if (spinner) spinner.style.display = 'none';
    }
}

// ==================================================
// GAME MANAGEMENT FUNCTIONS (Keep all game functions the same)
// ==================================================
function openKeyCreationModal(scriptIndex) {
    currentScriptIndexForKey = scriptIndex;
    currentScriptForKey = selectedGame?.scripts?.[scriptIndex];
    
    if (!currentScriptForKey) {
        showToast('Script not found', 'error');
        return;
    }
    
    // Reset form
    document.getElementById('newKeyName').value = '';
    document.getElementById('newKeyValue').value = '';
    document.getElementById('newKeyURL').value = '';
    document.getElementById('keyPreviewText').textContent = 'Fill in the fields above to see preview';
    document.getElementById('keyURLOutput').textContent = 'Will be generated after creating key';
    document.getElementById('keyCreationStatus').textContent = '';
    
    // Show modal
    document.getElementById('keyCreationModal').classList.remove('hidden');
    
    // Add event listeners for live preview
    document.getElementById('newKeyName').addEventListener('input', updateKeyPreview);
    document.getElementById('newKeyValue').addEventListener('input', updateKeyPreview);
    document.getElementById('newKeyURL').addEventListener('input', updateKeyPreview);
}

function closeKeyCreationModal() {
    document.getElementById('keyCreationModal').classList.add('hidden');
    currentScriptIndexForKey = null;
    currentScriptForKey = null;
}

function updateKeyPreview() {
    const name = document.getElementById('newKeyName').value.trim();
    const value = document.getElementById('newKeyValue').value.trim();
    const url = document.getElementById('newKeyURL').value.trim();
    const preview = document.getElementById('keyPreviewText');
    
    if (!name && !value && !url) {
        preview.textContent = 'Fill in the fields above to see preview';
        return;
    }
    
    let html = '';
    if (name) {
        html += `<strong>Name:</strong> ${name}<br>`;
    }
    if (value) {
        const hiddenValue = '‚Ä¢'.repeat(Math.min(value.length, 32)) + (value.length > 32 ? '...' : '');
        html += `<strong>Key:</strong> ${hiddenValue}<br>`;
    }
    if (url) {
        html += `<strong>URL:</strong> ${url.length > 30 ? url.substring(0, 30) + '...' : url}`;
    }
    
    preview.innerHTML = html;
}

function generateRandomKeyValue() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
    let key = '';
    for (let i = 0; i < 16; i++) {
        key += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    
    document.getElementById('newKeyValue').value = key;
    updateKeyPreview();
    
    showToast('Random key generated', 'info');
}

async function createNewKey() {
    const name = document.getElementById('newKeyName').value.trim();
    const value = document.getElementById('newKeyValue').value.trim();
    const url = document.getElementById('newKeyURL').value.trim();
    const status = document.getElementById('keyCreationStatus');
    const createBtn = document.getElementById('createKeyBtn');
    
    if (!name || !value) {
        status.textContent = 'Please fill in key name and value';
        status.style.color = 'var(--danger)';
        return;
    }
    
    showLoading('Creating key...');
    status.textContent = '';
    
    try {
        const data = await fetchData();
        
        // Find the game and script
        const gameIndex = data.games?.findIndex(g => g.id === selectedGame?.id);
        if (gameIndex === -1 || !data.games[gameIndex]?.scripts?.[currentScriptIndexForKey]) {
            throw new Error('Script not found');
        }
        
        const script = data.games[gameIndex].scripts[currentScriptIndexForKey];
        
        // Check if key with this name already exists
        if (script.keys?.some(k => k.name.toLowerCase() === name.toLowerCase())) {
            throw new Error('Key with this name already exists');
        }
        
        // Create key object
        const key = {
            name: name,
            value: value,
            url: url || '',
            addedBy: getUserIdentifier(),
            addedAt: Date.now()
        };
        
        // Initialize keys array if needed
        if (!script.keys) {
            script.keys = [];
        }
        
        script.keys.push(key);
        data.games[gameIndex].scripts[currentScriptIndexForKey] = script;
        data.settings.last_updated = Date.now();
        
        await batchUpdate([{ games: data.games, settings: data.settings }]);
        
        // Generate URL to copy
        const scriptURL = script.url || '';
        const keyURL = scriptURL + (scriptURL.includes('?') ? '&' : '?') + 
                      'key=' + encodeURIComponent(value) + 
                      '&name=' + encodeURIComponent(name);
        
        document.getElementById('keyURLOutput').textContent = keyURL;
        
        // Copy to clipboard
        try {
            await navigator.clipboard.writeText(keyURL);
            createBtn.innerHTML = '<span>‚úÖ Copied! Create Another</span>';
            showToast('Key created and URL copied to clipboard!', 'success');
        } catch (err) {
            showToast('Key created but failed to copy to clipboard', 'warning');
        }
        
        status.textContent = '‚úÖ Key created successfully!';
        status.style.color = 'var(--success)';
        
        // Reset form after delay
        setTimeout(() => {
            document.getElementById('newKeyName').value = '';
            document.getElementById('newKeyValue').value = '';
            document.getElementById('newKeyURL').value = '';
            updateKeyPreview();
            createBtn.innerHTML = '<span>üîë Create Key</span>';
            status.textContent = '';
        }, 2000);
        
    } catch (error) {
        console.error('Create key error:', error);
        status.textContent = error.message || 'Failed to create key';
        status.style.color = 'var(--danger)';
        showToast(error.message || 'Failed to create key', 'error');
    } finally {
        hideLoading();
    }
}

// ==================================================
// KEY DISPLAY AND COPY FUNCTIONS (Keep these the same)
// ==================================================
function toggleKeyDisplay(keyId) {
    const display = document.getElementById(`key-display-${keyId}`);
    const toggle = display?.nextElementSibling?.querySelector('.key-visibility-toggle');
    
    if (!display || !toggle) return;
    
    const data = dataCache;
    const game = data?.games?.find(g => g.id === selectedGame?.id);
    const script = game?.scripts?.find(s => s.keys?.some(k => k.name === keyId));
    const key = script?.keys?.find(k => k.name === keyId);
    
    if (!key) return;
    
    if (display.textContent.includes('‚Ä¢‚Ä¢‚Ä¢‚Ä¢')) {
        // Show key
        display.textContent = key.value;
        if (toggle) toggle.textContent = 'üîí Hide';
    } else {
        // Hide key
        display.textContent = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
        if (toggle) toggle.textContent = 'üëÅÔ∏è Show';
    }
}

async function copyKeyToClipboard(keyValue) {
    try {
        await navigator.clipboard.writeText(keyValue);
        
        // Show temporary notification
        const notification = document.createElement('div');
        notification.className = 'copied-notification';
        notification.textContent = 'Copied!';
        document.body.appendChild(notification);
        
        setTimeout(() => notification.remove(), 1000);
        
        showToast('Key copied to clipboard', 'success');
    } catch (err) {
        console.error('Failed to copy key:', err);
        showToast('Failed to copy key', 'error');
    }
}

// ==================================================
// SCRIPT KEY MANAGEMENT (Keep these the same)
// ==================================================
function toggleScriptKeys(scriptIndex) {
    const section = document.getElementById(`keys-section-${scriptIndex}`);
    if (!section) return;
    
    if (section.classList.contains('hidden')) {
        section.classList.remove('hidden');
        renderScriptKeys(scriptIndex);
    } else {
        section.classList.add('hidden');
    }
}

function renderScriptKeys(scriptIndex) {
    const container = document.getElementById(`keys-section-${scriptIndex}`);
    if (!container || !dataCache || !selectedGame) return;
    
    const script = selectedGame.scripts?.[scriptIndex];
    if (!script || !script.keys || script.keys.length === 0) {
        container.innerHTML = `
            <div class="no-keys-message">
                <span class="icon">üîë</span>
                <div>No keys added yet</div>
            </div>
        `;
        return;
    }
    
    const keysHtml = script.keys.map((key, keyIndex) => {
        const addedDate = new Date(key.addedAt || Date.now()).toLocaleDateString();
        return `
            <div class="key-item" id="key-item-${scriptIndex}-${keyIndex}">
                <div class="key-header">
                    <div class="key-title">
                        <span>üîë</span>
                        ${key.name || 'Unnamed Key'}
                    </div>
                    <div class="key-actions">
                        <button class="mini" onclick="editScriptKey(${scriptIndex}, ${keyIndex})" title="Edit Key">‚úèÔ∏è</button>
                        <button class="mini" onclick="copyKeyToClipboard('${key.value}')" title="Copy Key">üìã</button>
                        <button class="mini danger" onclick="deleteScriptKey(${scriptIndex}, ${keyIndex})" title="Delete Key">üóëÔ∏è</button>
                    </div>
                </div>
                ${key.url ? `<div class="key-url">${key.url}</div>` : ''}
                <div class="key-value" id="key-display-${key.name}">‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢</div>
                <div style="font-size:9px; opacity:0.6; display:flex; justify-content:space-between;">
                    <span>Added: ${addedDate}</span>
                    <span class="key-visibility-toggle" onclick="toggleKeyDisplay('${key.name}')" style="cursor:pointer;">üëÅÔ∏è Show</span>
                </div>
            </div>
        `;
    }).join('');
    
    container.innerHTML = keysHtml;
}

async function addScriptKey(scriptIndex) {
    const name = document.getElementById(`key-name-${scriptIndex}`)?.value.trim();
    const value = document.getElementById(`key-value-${scriptIndex}`)?.value.trim();
    const url = document.getElementById(`key-url-${scriptIndex}`)?.value.trim();
    const status = document.getElementById(`key-status-${scriptIndex}`);
    
    if (!name || !value) {
        if (status) {
            status.textContent = 'Please fill in key name and value';
            status.style.color = 'var(--danger)';
        }
        return;
    }
    
    showLoading('Adding key...');
    if (status) status.textContent = '';
    
    try {
        const data = await fetchData();
        
        // Find the game and script
        const gameIndex = data.games?.findIndex(g => g.id === selectedGame?.id);
        if (gameIndex === -1 || !data.games[gameIndex]?.scripts?.[scriptIndex]) {
            throw new Error('Script not found');
        }
        
        const script = data.games[gameIndex].scripts[scriptIndex];
        
        // Check if key with this name already exists
        if (script.keys?.some(k => k.name.toLowerCase() === name.toLowerCase())) {
            throw new Error('Key with this name already exists');
        }
        
        // Create key object
        const key = {
            name: name,
            value: value,
            url: url || '',
            addedBy: getUserIdentifier(),
            addedAt: Date.now()
        };
        
        // Initialize keys array if needed
        if (!script.keys) {
            script.keys = [];
        }
        
        script.keys.push(key);
        data.games[gameIndex].scripts[scriptIndex] = script;
        data.settings.last_updated = Date.now();
        
        await batchUpdate([{ games: data.games, settings: data.settings }]);
        
        // Reset form
        document.getElementById(`key-name-${scriptIndex}`).value = '';
        document.getElementById(`key-value-${scriptIndex}`).value = '';
        document.getElementById(`key-url-${scriptIndex}`).value = '';
        
        // Update display
        renderScriptKeys(scriptIndex);
        
        if (status) {
            status.textContent = '‚úÖ Key added successfully!';
            status.style.color = 'var(--success)';
        }
        
        showToast('Key added successfully!', 'success');
        
        // Clear status after delay
        setTimeout(() => {
            if (status) status.textContent = '';
        }, 3000);
        
    } catch (error) {
        console.error('Add key error:', error);
        if (status) {
            status.textContent = error.message || 'Failed to add key';
            status.style.color = 'var(--danger)';
        }
        showToast(error.message || 'Failed to add key', 'error');
    } finally {
        hideLoading();
    }
}

async function deleteScriptKey(scriptIndex, keyIndex) {
    if (!confirm('Delete this key? This action cannot be undone.')) return;
    
    showLoading('Deleting key...');
    
    try {
        const data = await fetchData();
        
        // Find the game and script
        const gameIndex = data.games?.findIndex(g => g.id === selectedGame?.id);
        if (gameIndex === -1 || !data.games[gameIndex]?.scripts?.[scriptIndex]) {
            throw new Error('Script not found');
        }
        
        const script = data.games[gameIndex].scripts[scriptIndex];
        if (!script.keys || !script.keys[keyIndex]) {
            throw new Error('Key not found');
        }
        
        // Remove the key
        script.keys.splice(keyIndex, 1);
        data.games[gameIndex].scripts[scriptIndex] = script;
        data.settings.last_updated = Date.now();
        
        await batchUpdate([{ games: data.games, settings: data.settings }]);
        
        // Update display
        renderScriptKeys(scriptIndex);
        
        showToast('Key deleted!', 'warning');
        
    } catch (error) {
        console.error('Delete key error:', error);
        showToast(error.message || 'Failed to delete key', 'error');
    } finally {
        hideLoading();
    }
}

async function editScriptKey(scriptIndex, keyIndex) {
    const newName = prompt('Enter new key name:', '');
    if (newName === null) return;
    
    const newURL = prompt('Enter new key URL (leave empty to remove):', '');
    if (newURL === null) return;
    
    const newValue = prompt('Enter new key value:', '');
    if (newValue === null) return;
    
    if (!newName || !newValue) {
        showToast('Key name and value are required', 'warning');
        return;
    }
    
    showLoading('Updating key...');
    
    try {
        const data = await fetchData();
        
        // Find the game and script
        const gameIndex = data.games?.findIndex(g => g.id === selectedGame?.id);
        if (gameIndex === -1 || !data.games[gameIndex]?.scripts?.[scriptIndex]) {
            throw new Error('Script not found');
        }
        
        const script = data.games[gameIndex].scripts[scriptIndex];
        if (!script.keys || !script.keys[keyIndex]) {
            throw new Error('Key not found');
        }
        
        // Update the key
        script.keys[keyIndex] = {
            ...script.keys[keyIndex],
            name: newName,
            value: newValue,
            url: newURL || '',
            addedBy: getUserIdentifier(),
            addedAt: Date.now()
        };
        
        data.games[gameIndex].scripts[scriptIndex] = script;
        data.settings.last_updated = Date.now();
        
        await batchUpdate([{ games: data.games, settings: data.settings }]);
        
        // Update display
        renderScriptKeys(scriptIndex);
        
        showToast('Key updated successfully!', 'success');
        
    } catch (error) {
        console.error('Edit key error:', error);
        showToast(error.message || 'Failed to update key', 'error');
    } finally {
        hideLoading();
    }
}

// ==================================================
// GAME MANAGEMENT VIEW FUNCTIONS (Keep these the same)
// ==================================================
function showGameCreateView() {
    document.getElementById('adminDefaultView').classList.add('hidden');
    document.getElementById('gameCreateView').classList.remove('hidden');
    
    // Reset form
    document.getElementById('gameNameInput').value = '';
    document.getElementById('gameIdInput').value = '';
    document.getElementById('gameImagePreview').style.display = 'none';
    document.getElementById('imagePlaceholder').style.display = 'block';
    document.getElementById('gameCreateStatus').textContent = '';
}

function showGamesDashboard() {
    document.getElementById('gameCreateView').classList.add('hidden');
    document.getElementById('scriptManagementView').classList.add('hidden');
    document.getElementById('adminDefaultView').classList.remove('hidden');
    loadGamesDashboard();
}

function showScriptManagement(game) {
    selectedGame = game;
    
    document.getElementById('adminDefaultView').classList.add('hidden');
    document.getElementById('scriptManagementView').classList.remove('hidden');
    
    // Update header
    document.getElementById('currentGameName').textContent = game.name;
    document.getElementById('currentGameId').textContent = `ID: ${game.id}`;
    
    if (game.image) {
        document.getElementById('currentGameImage').src = game.image;
        document.getElementById('currentGameImage').style.display = 'block';
    }
    
    loadGameScripts();
}

async function loadGamesDashboard() {
    try {
        const data = await fetchData();
        const games = data.games || [];
        const dashboard = document.getElementById('gamesDashboard');
        const noGamesMsg = document.getElementById('noGamesMessage');
        const totalGames = document.getElementById('totalGames');
        const totalScripts = document.getElementById('totalScripts');
        
        if (totalGames) {
            totalGames.textContent = `${games.length} game${games.length !== 1 ? 's' : ''}`;
        }
        
        let scriptCount = 0;
        games.forEach(game => {
            scriptCount += (game.scripts || []).length;
        });
        
        if (totalScripts) {
            totalScripts.textContent = `${scriptCount} script${scriptCount !== 1 ? 's' : ''}`;
        }
        
        if (games.length === 0) {
            if (dashboard) dashboard.innerHTML = '';
            if (noGamesMsg) noGamesMsg.classList.remove('hidden');
            return;
        }
        
        if (noGamesMsg) noGamesMsg.classList.add('hidden');
        
        const gamesHtml = games.map((game, index) => {
            const scriptCount = (game.scripts || []).length;
            return `
                <div class="game-card" onclick="showScriptManagement(${JSON.stringify(game).replace(/"/g, '&quot;')})">
                    <div class="game-actions">
                        <button class="game-action-btn delete" onclick="event.stopPropagation(); deleteGame(${index})" title="Delete Game">üóëÔ∏è</button>
                    </div>
                    ${game.image ? `<img src="${game.image}" class="game-card-image" alt="${game.name}">` : '<div class="game-card-image"></div>'}
                    <div class="game-card-title">${game.name}</div>
                    <div class="game-card-id">ID: ${game.id}</div>
                    <div class="game-card-scripts">${scriptCount} script${scriptCount !== 1 ? 's' : ''}</div>
                </div>
            `;
        }).join('');
        
        if (dashboard) {
            dashboard.innerHTML = gamesHtml;
        }
    } catch (error) {
        console.error('Error loading games dashboard:', error);
        showToast('Failed to load games', 'error');
    }
}

async function loadGameScripts() {
    if (!selectedGame) return;
    
    try {
        const data = await fetchData();
        const game = data.games?.find(g => g.id === selectedGame.id);
        
        if (!game) {
            showToast('Game not found', 'error');
            return;
        }
        
        const scripts = game.scripts || [];
        const scriptsList = document.getElementById('scriptsList');
        const noScriptsMsg = document.getElementById('noScriptsMessage');
        
        if (scripts.length === 0) {
            if (scriptsList) scriptsList.innerHTML = '';
            if (noScriptsMsg) noScriptsMsg.classList.remove('hidden');
            return;
        }
        
        if (noScriptsMsg) noScriptsMsg.classList.add('hidden');
        
        const scriptsHtml = scripts.map((script, index) => {
            const keyCount = (script.keys || []).length;
            return `
                <div class="script-item ${keyCount > 0 ? 'script-item-with-keys' : ''}">
                    <div class="script-url">${script.url}</div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong>${script.name}</strong>
                            ${keyCount > 0 ? `<span class="script-keys-indicator">üîë ${keyCount} key${keyCount !== 1 ? 's' : ''}</span>` : ''}
                        </div>
                        <div class="script-actions">
                            <button class="mini" onclick="openKeyCreationModal(${index})" title="Add Key">üîë</button>
                            <button class="mini danger" onclick="deleteScript(${index})" title="Delete Script">üóëÔ∏è</button>
                        </div>
                    </div>
                    
                    <!-- Keys Section -->
                    <div class="keys-section-header">
                        <h4>üîë Keys</h4>
                        <button class="toggle-keys-btn" onclick="toggleScriptKeys(${index})">Show/Hide Keys</button>
                    </div>
                    <div id="keys-section-${index}" class="keys-container hidden">
                        <!-- Keys will be rendered here -->
                    </div>
                    
                    <!-- Add Key Form -->
                    <div class="add-key-form">
                        <h5>‚ûï Add New Key</h5>
                        <div class="form-row">
                            <input type="text" id="key-name-${index}" placeholder="Key Name">
                            <input type="text" id="key-value-${index}" placeholder="Key Value">
                        </div>
                        <input type="text" id="key-url-${index}" placeholder="Optional URL">
                        <button class="mini" onclick="addScriptKey(${index})">Add Key</button>
                        <div id="key-status-${index}" style="margin-top: 8px; font-size: 11px;"></div>
                    </div>
                </div>
            `;
        }).join('');
        
        if (scriptsList) {
            scriptsList.innerHTML = scriptsHtml;
        }
        
        // Render keys for each script
        scripts.forEach((script, index) => {
            renderScriptKeys(index);
        });
    } catch (error) {
        console.error('Error loading game scripts:', error);
        showToast('Failed to load scripts', 'error');
    }
}

async function createGame() {
    const name = document.getElementById('gameNameInput').value.trim();
    const id = document.getElementById('gameIdInput').value.trim();
    const status = document.getElementById('gameCreateStatus');
    
    if (!name || !id) {
        if (status) {
            status.textContent = 'Please fill in all fields';
            status.style.color = 'var(--danger)';
        }
        return;
    }
    
    if (!/^\d+$/.test(id)) {
        if (status) {
            status.textContent = 'Game ID must be numeric';
            status.style.color = 'var(--danger)';
        }
        return;
    }
    
    showLoading('Creating game...');
    if (status) status.textContent = '';
    
    try {
        const data = await fetchData();
        
        // Check if game with this ID already exists
        if (data.games?.some(g => g.id === id)) {
            throw new Error('Game with this ID already exists');
        }
        
        // Handle image upload
        const imageInput = document.getElementById('gameImageInput');
        let imageData = '';
        
        if (imageInput.files && imageInput.files[0]) {
            const file = imageInput.files[0];
            if (file.size > 2 * 1024 * 1024) {
                throw new Error('Image must be less than 2MB');
            }
            
            // Convert to base64
            imageData = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        // Create game object
        const game = {
            id: id,
            name: name,
            image: imageData,
            scripts: [],
            created: Date.now(),
            createdBy: getUserIdentifier()
        };
        
        if (!data.games) {
            data.games = [];
        }
        
        data.games.push(game);
        data.settings.last_updated = Date.now();
        
        await batchUpdate([{ games: data.games, settings: data.settings }]);
        
        // Reset form
        document.getElementById('gameNameInput').value = '';
        document.getElementById('gameIdInput').value = '';
        document.getElementById('gameImagePreview').style.display = 'none';
        document.getElementById('imagePlaceholder').style.display = 'block';
        imageInput.value = '';
        
        if (status) {
            status.textContent = '‚úÖ Game created successfully!';
            status.style.color = 'var(--success)';
        }
        
        showToast('Game created successfully!', 'success');
        
        // Return to dashboard after delay
        setTimeout(() => {
            showGamesDashboard();
        }, 1500);
        
    } catch (error) {
        console.error('Error creating game:', error);
        if (status) {
            status.textContent = error.message || 'Failed to create game';
            status.style.color = 'var(--danger)';
        }
        showToast(error.message || 'Failed to create game', 'error');
    } finally {
        hideLoading();
    }
}

async function deleteGame(gameIndex) {
    if (!confirm('Delete this game and all its scripts? This action cannot be undone.')) return;
    
    showLoading('Deleting game...');
    
    try {
        const data = await fetchData();
        
        if (!data.games || !data.games[gameIndex]) {
            throw new Error('Game not found');
        }
        
        const gameName = data.games[gameIndex].name;
        data.games.splice(gameIndex, 1);
        data.settings.last_updated = Date.now();
        
        await batchUpdate([{ games: data.games, settings: data.settings }]);
        
        showToast(`Game "${gameName}" deleted`, 'warning');
        loadGamesDashboard();
        
    } catch (error) {
        console.error('Error deleting game:', error);
        showToast(error.message || 'Failed to delete game', 'error');
    } finally {
        hideLoading();
    }
}

async function addScriptToGame() {
    const name = document.getElementById('scriptNameInput').value.trim();
    const url = document.getElementById('scriptUrlInput').value.trim();
    const status = document.getElementById('scriptAddStatus');
    
    if (!name || !url) {
        if (status) {
            status.textContent = 'Please fill in all fields';
            status.style.color = 'var(--danger)';
        }
        return;
    }
    
    // Validate URL
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
        if (status) {
            status.textContent = 'URL must start with http:// or https://';
            status.style.color = 'var(--danger)';
        }
        return;
    }
    
    showLoading('Adding script...');
    if (status) status.textContent = '';
    
    try {
        const data = await fetchData();
        
        // Find the game
        const gameIndex = data.games?.findIndex(g => g.id === selectedGame?.id);
        if (gameIndex === -1) {
            throw new Error('Game not found');
        }
        
        // Check if script with this URL already exists
        const existingScript = data.games[gameIndex].scripts?.find(s => s.url === url);
        if (existingScript) {
            throw new Error('Script with this URL already exists');
        }
        
        // Create script object
        const script = {
            name: name,
            url: url,
            added: Date.now(),
            addedBy: getUserIdentifier(),
            keys: []
        };
        
        if (!data.games[gameIndex].scripts) {
            data.games[gameIndex].scripts = [];
        }
        
        data.games[gameIndex].scripts.push(script);
        data.settings.last_updated = Date.now();
        
        await batchUpdate([{ games: data.games, settings: data.settings }]);
        
        // Reset form
        document.getElementById('scriptNameInput').value = '';
        document.getElementById('scriptUrlInput').value = '';
        
        if (status) {
            status.textContent = '‚úÖ Script added successfully!';
            status.style.color = 'var(--success)';
        }
        
        showToast('Script added successfully!', 'success');
        
        // Reload scripts
        loadGameScripts();
        
        // Clear status after delay
        setTimeout(() => {
            if (status) status.textContent = '';
        }, 3000);
        
    } catch (error) {
        console.error('Error adding script:', error);
        if (status) {
            status.textContent = error.message || 'Failed to add script';
            status.style.color = 'var(--danger)';
        }
        showToast(error.message || 'Failed to add script', 'error');
    } finally {
        hideLoading();
    }
}

async function deleteScript(scriptIndex) {
    if (!confirm('Delete this script and all its keys? This action cannot be undone.')) return;
    
    showLoading('Deleting script...');
    
    try {
        const data = await fetchData();
        
        // Find the game
        const gameIndex = data.games?.findIndex(g => g.id === selectedGame?.id);
        if (gameIndex === -1) {
            throw new Error('Game not found');
        }
        
        if (!data.games[gameIndex].scripts || !data.games[gameIndex].scripts[scriptIndex]) {
            throw new Error('Script not found');
        }
        
        const scriptName = data.games[gameIndex].scripts[scriptIndex].name;
        data.games[gameIndex].scripts.splice(scriptIndex, 1);
        data.settings.last_updated = Date.now();
        
        await batchUpdate([{ games: data.games, settings: data.settings }]);
        
        showToast(`Script "${scriptName}" deleted`, 'warning');
        loadGameScripts();
        
    } catch (error) {
        console.error('Error deleting script:', error);
        showToast(error.message || 'Failed to delete script', 'error');
    } finally {
        hideLoading();
    }
}

// ==================================================
// IMAGE UPLOAD HANDLING (Keep this the same)
// ==================================================
document.getElementById('gameImageInput')?.addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    // Check file size (max 2MB)
    if (file.size > 2 * 1024 * 1024) {
        showToast('Image must be less than 2MB', 'error');
        return;
    }
    
    // Check file type
    if (!file.type.match('image.*')) {
        showToast('Please select an image file', 'error');
        return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const preview = document.getElementById('gameImagePreview');
        const placeholder = document.getElementById('imagePlaceholder');
        
        if (preview && placeholder) {
            preview.src = e.target.result;
            preview.style.display = 'block';
            placeholder.style.display = 'none';
        }
    };
    reader.readAsDataURL(file);
});

// ==================================================
// ADMIN FUNCTIONS (Keep these the same)
// ==================================================
function toggleAdmin() {
    const adminInput = document.getElementById('adminInput');
    const adminBtn = document.getElementById('adminBtn');
    
    if (!adminInput || !adminBtn) return;
    
    if (adminInput.classList.contains('hidden')) {
        adminInput.classList.remove('hidden');
        adminInput.focus();
    } else {
        const input = adminInput.value.trim();
        adminInput.value = '';
        adminInput.classList.add('hidden');
        
        if (input === 'ADMIN_MASTER_KEY_123') { // Change this to your actual master key
            isAdminAuthenticated = true;
            adminBtn.textContent = 'üëë Admin Panel';
            showToast('Admin access granted', 'success');
            openAdminPanel();
        } else {
            showToast('Invalid master key', 'error');
        }
    }
}

function openAdminPanel() {
    if (!isAdminAuthenticated) {
        showToast('Admin access required', 'error');
        return;
    }
    
    document.getElementById('mainSystem').classList.add('hidden');
    document.getElementById('adminPanel').classList.remove('hidden');
    loadGamesDashboard();
    renderAdminKeys();
    renderAdminBans();
}

function closeAdmin() {
    document.getElementById('adminPanel').classList.add('hidden');
    document.getElementById('mainSystem').classList.remove('hidden');
}

// ==================================================
// INITIALIZATION
// ==================================================
document.addEventListener('DOMContentLoaded', async () => {
    // Initialize time display
    updateStatsDisplay();
    setInterval(updateStatsDisplay, 60000); // Update every minute
    
    // Track view and activity
    trackViewAndActivity();
    setInterval(trackViewAndActivity, 30000); // Update activity every 30 seconds
    
    // Initialize database
    await initializeDatabase();
    
    // Load initial data
    await fetchData();
    
    // Update chat
    updateChat();
    setInterval(updateChat, 5000); // Update chat every 5 seconds
    
    // Show main system
    document.getElementById('authPanel').classList.add('hidden');
    document.getElementById('mainSystem').classList.remove('hidden');
    
    // Set up event listeners
    const chatInput = document.getElementById('chat-input');
    if (chatInput) {
        chatInput.addEventListener('input', handleTyping);
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendChat();
            }
        });
    }
    
    const chatToggle = document.getElementById('chat-toggle');
    if (chatToggle) {
        chatToggle.addEventListener('click', () => toggleChat(true));
    }
    
    // Set up admin button
    const adminBtn = document.getElementById('adminBtn');
    if (adminBtn) {
        adminBtn.classList.remove('hidden');
        adminBtn.addEventListener('click', toggleAdmin);
    }
    
    showToast('System initialized with JSONBin', 'success');
});

// ==================================================
// CHAT WINDOW TOGGLE
// ==================================================
function toggleChat(show) {
    const chatWindow = document.getElementById('chat-window');
    if (!chatWindow) return;
    
    if (show) {
        chatWindow.classList.remove('hidden');
        unreadCount = 0;
        updateUnreadBadge();
    } else {
        chatWindow.classList.add('hidden');
    }
}

// ==================================================
// FEEDBACK FUNCTIONS (Keep these the same)
// ==================================================
function toggleFeedbackUI(show) {
    const feedbackUI = document.getElementById('userFeedbackUI');
    const mainSystem = document.getElementById('mainSystem');
    
    if (show) {
        mainSystem.classList.add('hidden');
        feedbackUI.classList.remove('hidden');
        
        // Set up character counter
        const fbMsg = document.getElementById('fb-msg');
        const fbCharCount = document.getElementById('fbCharCount');
        
        if (fbMsg && fbCharCount) {
            fbMsg.addEventListener('input', () => {
                const length = fbMsg.value.length;
                fbCharCount.textContent = `${length}/500`;
                if (length > 500) {
                    fbCharCount.style.color = 'var(--danger)';
                } else {
                    fbCharCount.style.color = 'rgba(255, 255, 255, 0.5)';
                }
            });
        }
    } else {
        feedbackUI.classList.add('hidden');
        mainSystem.classList.remove('hidden');
    }
}

async function submitFeedback() {
    const user = document.getElementById('fb-user')?.value.trim();
    const id = document.getElementById('fb-id')?.value.trim();
    const msg = document.getElementById('fb-msg')?.value.trim();
    const spinner = document.getElementById('fbSpinner');
    
    if (!user || !id || !msg) {
        showToast('Please fill in all fields', 'error');
        return;
    }
    
    if (msg.length > 500) {
        showToast('Feedback must be 500 characters or less', 'error');
        return;
    }
    
    if (spinner) spinner.style.display = 'inline-block';
    
    try {
        const data = await fetchData();
        
        if (!data.feedbacks) {
            data.feedbacks = [];
        }
        
        const feedback = {
            user: user,
            userId: id,
            message: msg,
            timestamp: Date.now(),
            status: 'pending'
        };
        
        data.feedbacks.push(feedback);
        data.settings.last_updated = Date.now();
        
        await batchUpdate([{ feedbacks: data.feedbacks, settings: data.settings }]);
        
        // Reset form
        document.getElementById('fb-user').value = '';
        document.getElementById('fb-id').value = '';
        document.getElementById('fb-msg').value = '';
        document.getElementById('fbCharCount').textContent = '0/500';
        
        showToast('Feedback submitted successfully!', 'success');
        toggleFeedbackUI(false);
        
    } catch (error) {
        console.error('Error submitting feedback:', error);
        showToast('Failed to submit feedback', 'error');
    } finally {
        if (spinner) spinner.style.display = 'none';
    }
}

// ==================================================
// ADMIN FEEDBACK MANAGEMENT (Keep these the same)
// ==================================================
function openAdminFeedbacks() {
    if (!isAdminAuthenticated) {
        showToast('Admin access required', 'error');
        return;
    }
    
    document.getElementById('adminDefaultView').classList.add('hidden');
    document.getElementById('adminFeedbackListView').classList.remove('hidden');
    renderAdminFeedbacks();
}

function returnToAdminPanel() {
    document.getElementById('adminFeedbackListView').classList.add('hidden');
    document.getElementById('adminViewFeedbackUI').classList.add('hidden');
    document.getElementById('adminDefaultView').classList.remove('hidden');
}

async function renderAdminFeedbacks() {
    try {
        const data = await fetchData();
        const feedbacks = data.feedbacks || [];
        const searchTerm = document.getElementById('fbSearch')?.value.toLowerCase() || '';
        
        const filteredFeedbacks = feedbacks.filter(fb => 
            fb.user.toLowerCase().includes(searchTerm) || 
            fb.userId.toLowerCase().includes(searchTerm)
        );
        
        const container = document.getElementById('fbLogs');
        if (!container) return;
        
        if (filteredFeedbacks.length === 0) {
            container.innerHTML = '<div style="text-align: center; padding: 40px; color: rgba(255,255,255,0.5);">No feedback submissions</div>';
            return;
        }
        
        const html = filteredFeedbacks.map((fb, index) => {
            const date = new Date(fb.timestamp).toLocaleString();
            return `
                <div class="fb-item">
                    <div>
                        <strong>${fb.user}</strong> (${fb.userId})<br>
                        <small>${date}</small>
                    </div>
                    <div>
                        <button class="mini" onclick="viewFeedback(${index})">View</button>
                        <button class="mini danger" onclick="deleteFeedback(${index})">Delete</button>
                    </div>
                </div>
            `;
        }).join('');
        
        container.innerHTML = html;
    } catch (error) {
        console.error('Error rendering feedbacks:', error);
        showToast('Failed to load feedbacks', 'error');
    }
}

function viewFeedback(index) {
    const container = document.getElementById('adminViewFeedbackUI');
    const title = document.getElementById('viewFbTitle');
    const content = document.getElementById('viewFbContent');
    
    if (!container || !title || !content) return;
    
    document.getElementById('adminFeedbackListView').classList.add('hidden');
    container.classList.remove('hidden');
    
    const feedback = dataCache.feedbacks?.[index];
    if (!feedback) {
        content.textContent = 'Feedback not found';
        return;
    }
    
    const date = new Date(feedback.timestamp).toLocaleString();
    title.textContent = `üìÑ Feedback from ${feedback.user}`;
    
    content.innerHTML = `
        <p><strong>User:</strong> ${feedback.user}</p>
        <p><strong>UserID:</strong> ${feedback.userId}</p>
        <p><strong>Submitted:</strong> ${date}</p>
        <p><strong>Status:</strong> ${feedback.status || 'pending'}</p>
        <hr style="border-color: rgba(255,255,255,0.1); margin: 15px 0;">
        <p><strong>Message:</strong></p>
        <p style="white-space: pre-wrap; background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">${feedback.message}</p>
    `;
}

function closeSingleFeedback() {
    document.getElementById('adminViewFeedbackUI').classList.add('hidden');
    document.getElementById('adminFeedbackListView').classList.remove('hidden');
}

async function deleteFeedback(index) {
    if (!confirm('Delete this feedback?')) return;
    
    try {
        const data = await fetchData();
        if (!data.feedbacks || !data.feedbacks[index]) {
            throw new Error('Feedback not found');
        }
        
        data.feedbacks.splice(index, 1);
        data.settings.last_updated = Date.now();
        
        await batchUpdate([{ feedbacks: data.feedbacks, settings: data.settings }]);
        
        showToast('Feedback deleted', 'warning');
        renderAdminFeedbacks();
    } catch (error) {
        console.error('Error deleting feedback:', error);
        showToast('Failed to delete feedback', 'error');
    }
}

// ==================================================
// ADMIN KEY MANAGEMENT (Keep these the same)
// ==================================================
async function renderAdminKeys() {
    try {
        const data = await fetchData();
        const keys = data.keys || {};
        const container = document.getElementById('keyLogs');
        const countElement = document.getElementById('keyCount');
        
        if (countElement) {
            countElement.textContent = `${Object.keys(keys).length} key${Object.keys(keys).length !== 1 ? 's' : ''}`;
        }
        
        if (!container) return;
        
        if (Object.keys(keys).length === 0) {
            container.innerHTML = '<div style="text-align: center; padding: 40px; color: rgba(255,255,255,0.5);">No keys in system</div>';
            return;
        }
        
        const html = Object.entries(keys).map(([key, info]) => {
            const created = new Date(info.created || Date.now()).toLocaleString();
            return `
                <div style="background: rgba(255,255,255,0.03); padding: 10px; border-radius: 8px; margin-bottom: 8px;">
                    <div style="display: flex; justify-content: space-between;">
                        <strong style="color: var(--secondary);">${key.substring(0, 8)}...</strong>
                        <button class="mini danger" onclick="deleteAdminKey('${key}')">Delete</button>
                    </div>
                    <div style="font-size: 11px; opacity: 0.8;">
                        UserID: ${info.rbx}<br>
                        Added by: ${info.added_by || 'system'}<br>
                        Created: ${created}<br>
                        Expires: ${info.exp === 'INF' ? 'Never' : new Date(parseInt(info.exp)).toLocaleString()}
                    </div>
                </div>
            `;
        }).join('');
        
        container.innerHTML = html;
    } catch (error) {
        console.error('Error rendering admin keys:', error);
        showToast('Failed to load keys', 'error');
    }
}

async function deleteAdminKey(key) {
    if (!confirm('Delete this key?')) return;
    
    try {
        const data = await fetchData();
        if (!data.keys || !data.keys[key]) {
            throw new Error('Key not found');
        }
        
        delete data.keys[key];
        data.settings.last_updated = Date.now();
        
        await batchUpdate([{ keys: data.keys, settings: data.settings }]);
        
        showToast('Key deleted', 'warning');
        renderAdminKeys();
    } catch (error) {
        console.error('Error deleting key:', error);
        showToast('Failed to delete key', 'error');
    }
}

// ==================================================
// ADMIN BAN MANAGEMENT (Keep these the same)
// ==================================================
async function renderAdminBans() {
    try {
        const data = await fetchData();
        const bans = data.bans || {};
        const container = document.getElementById('banLogs');
        const countElement = document.getElementById('banCount');
        
        if (countElement) {
            countElement.textContent = `${Object.keys(bans).length} banned`;
        }
        
        if (!container) return;
        
        if (Object.keys(bans).length === 0) {
            container.innerHTML = '<div style="text-align: center; padding: 40px; color: rgba(255,255,255,0.5);">No banned users</div>';
            return;
        }
        
        const html = Object.entries(bans).map(([userId, info]) => {
            const bannedDate = new Date(info.time || Date.now()).toLocaleString();
            return `
                <div style="background: rgba(255,59,48,0.1); padding: 10px; border-radius: 8px; margin-bottom: 8px; border-left: 3px solid var(--danger);">
                    <div style="display: flex; justify-content: space-between;">
                        <strong>${userId}</strong>
                        <button class="mini success" onclick="unbanUser('${userId}')">Unban</button>
                    </div>
                    <div style="font-size: 11px; opacity: 0.8;">
                        Reason: ${info.reason || 'No reason provided'}<br>
                        Banned by: ${info.banned_by || 'system'}<br>
                        Date: ${bannedDate}
                    </div>
                </div>
            `;
        }).join('');
        
        container.innerHTML = html;
    } catch (error) {
        console.error('Error rendering bans:', error);
        showToast('Failed to load bans', 'error');
    }
}

async function banAllKeyHolders() {
    if (!confirm('Ban all key holders? This will ban every user who has a key.')) return;
    
    showLoading('Banning all key holders...');
    
    try {
        const data = await fetchData();
        const keys = data.keys || {};
        
        if (!data.bans) {
            data.bans = {};
        }
        
        let count = 0;
        for (const [key, info] of Object.entries(keys)) {
            if (info.rbx && !data.bans[info.rbx]) {
                data.bans[info.rbx] = {
                    reason: 'Mass ban of all key holders',
                    banned_by: getUserIdentifier(),
                    time: Date.now()
                };
                count++;
            }
        }
        
        data.settings.last_updated = Date.now();
        
        await batchUpdate([{ bans: data.bans, settings: data.settings }]);
        
        showToast(`Banned ${count} key holders`, 'warning');
        renderAdminBans();
    } catch (error) {
        console.error('Error banning key holders:', error);
        showToast('Failed to ban key holders', 'error');
    } finally {
        hideLoading();
    }
}

async function unbanEveryone() {
    if (!confirm('Unban all users?')) return;
    
    showLoading('Unbanning all users...');
    
    try {
        const data = await fetchData();
        data.bans = {};
        data.settings.last_updated = Date.now();
        
        await batchUpdate([{ bans: data.bans, settings: data.settings }]);
        
        showToast('All users unbanned', 'success');
        renderAdminBans();
    } catch (error) {
        console.error('Error unbanning users:', error);
        showToast('Failed to unban users', 'error');
    } finally {
        hideLoading();
    }
}

async function unbanUser(userId) {
    if (!confirm(`Unban user ${userId}?`)) return;
    
    try {
        const data = await fetchData();
        if (!data.bans || !data.bans[userId]) {
            throw new Error('User not banned');
        }
        
        delete data.bans[userId];
        data.settings.last_updated = Date.now();
        
        await batchUpdate([{ bans: data.bans, settings: data.settings }]);
        
        showToast(`Unbanned user ${userId}`, 'success');
        renderAdminBans();
    } catch (error) {
        console.error('Error unbanning user:', error);
        showToast('Failed to unban user', 'error');
    }
}

// ==================================================
// ADMIN BROADCAST FUNCTIONS (Keep these the same)
// ==================================================
async function sendGlobalMsg(pin = false) {
    const input = document.getElementById('globalMsgInput');
    if (!input) return;
    
    const text = input.value.trim();
    if (!text) {
        showToast('Please enter a message', 'error');
        return;
    }
    
    if (text.length > 200) {
        showToast('Message must be 200 characters or less', 'error');
        return;
    }
    
    showLoading(pin ? 'Pinning message...' : 'Sending broadcast...');
    
    try {
        const data = await fetchData();
        
        if (pin) {
            // Pin message
            data.pinned = {
                text: text,
                pinnedBy: getUserIdentifier(),
                pinnedAt: Date.now()
            };
            
            await batchUpdate([{ pinned: data.pinned }]);
            showToast('Message pinned', 'success');
        } else {
            // Send as system message
            const message = {
                user: 'SYSTEM',
                txt: text,
                timestamp: Date.now()
            };
            
            if (!data.chats) {
                data.chats = [];
            }
            
            data.chats.push(message);
            
            // Keep only last 100 messages
            if (data.chats.length > 100) {
                data.chats = data.chats.slice(-100);
            }
            
            await batchUpdate([{ chats: data.chats }]);
            showToast('Broadcast sent', 'success');
        }
        
        input.value = '';
        updateChat();
    } catch (error) {
        console.error('Error sending message:', error);
        showToast('Failed to send message', 'error');
    } finally {
        hideLoading();
    }
}

async function clearGlobals() {
    if (!confirm('Clear all pinned and system messages?')) return;
    
    showLoading('Clearing messages...');
    
    try {
        const data = await fetchData();
        data.pinned = null;
        
        // Remove system messages from chat
        if (data.chats) {
            data.chats = data.chats.filter(msg => msg.user !== 'SYSTEM');
        }
        
        await batchUpdate([{ pinned: data.pinned, chats: data.chats }]);
        
        showToast('Messages cleared', 'success');
        updateChat();
    } catch (error) {
        console.error('Error clearing messages:', error);
        showToast('Failed to clear messages', 'error');
    } finally {
        hideLoading();
    }
}

async function clearAllChat() {
    if (!confirm('Clear all chat messages? This cannot be undone.')) return;
    
    showLoading('Clearing chat...');
    
    try {
        const data = await fetchData();
        data.chats = [];
        
        await batchUpdate([{ chats: data.chats }]);
        
        showToast('Chat cleared', 'success');
        updateChat();
    } catch (error) {
        console.error('Error clearing chat:', error);
        showToast('Failed to clear chat', 'error');
    } finally {
        hideLoading();
    }
}

// ==================================================
// ADMIN BAN NOW FUNCTIONALITY (Keep these the same)
// ==================================================
function toggleBanNowView(show) {
    const banNowView = document.getElementById('banNowView');
    const adminDefaultView = document.getElementById('adminDefaultView');
    
    if (show) {
        adminDefaultView.classList.add('hidden');
        banNowView.classList.remove('hidden');
        
        // Set up character counter
        const reasonInput = document.getElementById('focusBanReason');
        const charCount = document.getElementById('reasonCharCount');
        
        if (reasonInput && charCount) {
            reasonInput.addEventListener('input', () => {
                const length = reasonInput.value.length;
                charCount.textContent = `${length}/200`;
                if (length > 200) {
                    charCount.style.color = 'var(--danger)';
                } else {
                    charCount.style.color = 'rgba(255, 255, 255, 0.5)';
                }
            });
        }
    } else {
        banNowView.classList.add('hidden');
        adminDefaultView.classList.remove('hidden');
    }
}

async function executeFocusBan() {
    const userId = document.getElementById('focusBanId')?.value.trim();
    const username = document.getElementById('focusBanUser')?.value.trim();
    const reason = document.getElementById('focusBanReason')?.value.trim();
    
    if (!userId || !username) {
        showToast('Please fill in UserID and Username', 'error');
        return;
    }
    
    if (reason && reason.length > 200) {
        showToast('Reason must be 200 characters or less', 'error');
        return;
    }
    
    showLoading('Banning user...');
    
    try {
        const data = await fetchData();
        
        if (!data.bans) {
            data.bans = {};
        }
        
        data.bans[userId] = {
            reason: reason || 'Violation of terms',
            banned_by: getUserIdentifier(),
            time: Date.now(),
            username: username
        };
        
        data.settings.last_updated = Date.now();
        
        await batchUpdate([{ bans: data.bans, settings: data.settings }]);
        
        // Clear form
        document.getElementById('focusBanId').value = '';
        document.getElementById('focusBanUser').value = '';
        document.getElementById('focusBanReason').value = '';
        document.getElementById('reasonCharCount').textContent = '0/200';
        
        showToast(`Banned ${username} (${userId})`, 'success');
        toggleBanNowView(false);
        renderAdminBans();
    } catch (error) {
        console.error('Error banning user:', error);
        showToast('Failed to ban user', 'error');
    } finally {
        hideLoading();
    }
}

// ==================================================
// SYSTEM RESET FUNCTIONS (Keep these the same)
// ==================================================
async function masterReset() {
    const target = document.getElementById('resetTarget')?.value;
    if (!target) return;
    
    let message = '';
    switch (target) {
        case 'chat':
            message = 'Clear all chat history?';
            break;
        case 'bans':
            message = 'Clear all bans?';
            break;
        case 'users':
            message = 'Clear all user accounts? This will remove all user data.';
            break;
        case 'all':
            message = 'FACTORY RESET: This will wipe EVERYTHING and cannot be undone. Continue?';
            break;
        default:
            return;
    }
    
    if (!confirm(message)) return;
    
    showLoading('Resetting system...');
    
    try {
        const data = await fetchData();
        
        switch (target) {
            case 'chat':
                data.chats = [];
                data.pinned = null;
                break;
            case 'bans':
                data.bans = {};
                break;
            case 'users':
                data.keys = {};
                data.feedbacks = [];
                break;
            case 'all':
                // Factory reset - create fresh database
                const initialData = {
                    keys: {},
                    games: [],
                    bans: {},
                    feedbacks: [],
                    chats: [],
                    pinned: null,
                    admins: {
                        [getUserIdentifier()]: {
                            name: 'System Admin',
                            added: Date.now(),
                            level: 3
                        }
                    },
                    settings: {
                        version: "2.0",
                        created: Date.now(),
                        last_updated: Date.now()
                    }
                };
                
                await makeJsonBinRequest('PUT', initialData);
                dataCache = initialData;
                lastFetchTime = Date.now();
                
                showToast('Factory reset complete', 'success');
                hideLoading();
                location.reload(); // Reload page to reflect changes
                return;
        }
        
        data.settings.last_updated = Date.now();
        
        await batchUpdate([data]);
        
        showToast('Reset complete', 'success');
        
        // Refresh displays
        updateChat();
        renderAdminKeys();
        renderAdminBans();
        loadGamesDashboard();
        
    } catch (error) {
        console.error('Error resetting system:', error);
        showToast('Failed to reset system', 'error');
    } finally {
        hideLoading();
    }
}

// ==================================================
// AUTHENTICATION FUNCTIONS (Keep these the same)
// ==================================================
function toggleAuth(isSignup) {
    const loginView = document.getElementById('loginView');
    const signupView = document.getElementById('signupView');
    const authStatus = document.getElementById('authStatus');
    
    if (authStatus) authStatus.textContent = '';
    
    if (isSignup) {
        loginView.classList.add('hidden');
        signupView.classList.remove('hidden');
    } else {
        signupView.classList.add('hidden');
        loginView.classList.remove('hidden');
    }
}

function handleAuth(type) {
    const spinner = type === 'login' ? 
        document.getElementById('loginSpinner') : 
        document.getElementById('signupSpinner');
    const authStatus = document.getElementById('authStatus');
    
    if (spinner) spinner.style.display = 'inline-block';
    if (authStatus) authStatus.textContent = '';
    
    // For demo purposes, just show success
    setTimeout(() => {
        if (spinner) spinner.style.display = 'none';
        document.getElementById('authPanel').classList.add('hidden');
        document.getElementById('mainSystem').classList.remove('hidden');
        showToast(`Successfully ${type === 'login' ? 'logged in' : 'signed up'}!`, 'success');
    }, 1000);
}

function logout() {
    if (confirm('Logout from the system?')) {
        document.getElementById('mainSystem').classList.add('hidden');
        document.getElementById('authPanel').classList.remove('hidden');
        document.getElementById('loginView').classList.remove('hidden');
        document.getElementById('signupView').classList.add('hidden');
        showToast('Logged out successfully', 'info');
    }
}
</script>
</body> 
</html>
